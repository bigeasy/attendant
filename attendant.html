<!DOCTYPE html>
<html>
<head>
<title>attendant.c</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<link rel="stylesheet" media="all" href="/attendant/css/docco.css">
</head>
<body>
<div id="container">
<div id="background"></div>
  <table cellspacing="0" cellpadding="0">
    <thead>
      <tr>
        <th class="docs"><h1>attendant.c</th>
        <th class="code"></th>
      </tr>
    </thead>
    <tbody>
      
        <tr>
          <td class="docs"><p>A process monitor that watches a single out-of-process server on behalf of a
dynamically loaded plugin running within the context of a host application. </p>

<p>Attendant was written for use in an <a href="https://wiki.mozilla.org/NPAPI">NPAPI</a>
plugin, but there is no NPAPI specific code here. I imagine that Attendant
could work with any similar plugin architecture, where a host application
loads a plugin that is implemented as dynamically linked library.</p>

<p>Attendant allows a plugin to launch a single server process. With this single
server process you can implement your plugin as a proxy to an out-of-process
server that performs the real work of the plugin. It isolates the complexity
of the plugin in a separate process, so that catastrophic errors will kill
only the plugin server, and not the host application.</p>

<p>Attendant is supposed to monitor only the single server process. The server
process will start when the library loads. The server process will shutdown
when the library is unloaded and cannot be restarted. If the server process
exits before shutdown, the exit is considered abnormal, and recovery ensues.</p>

<p>This behavior is proscribed, intentional and not a limitation of the
Attendant's ability. It is a limitation of the Attendant's scope.</p>

<p>If you need to launch multiple processes to service your plugin, then make
the first process you launch a process that monitors your flock of processes.
Attendant is not a general purpose process monitor, it focues on the
challenges of monitoring a single process in the context of a host
application that may or may not expect plugins to launch child processes. It
isolates the plugin server process from the host application and vice versa. </p>

<p>The Attendant is only a process monitor. It does not provide a API for
communication between the plugin stub and the plugin process. </p>

<p>You can initialize inter-process communication using command line arguments
and the redirected standard I/O pipes. You can commicate using named pipes
or TCP/IP sockets.</p>

<p>You might decide that standard I/O is sufficient for inter-process
communication between your plugin stub and the plugin process.  You are still
responsible for desiging a protocol that will use the standard I/O pipes.</p>

<p>Attendant may not work with all host applications, but it does its best to be
as unobtrusive as possible. It forks and execs calling only async-safe system
calls to dup the pipes that redirect stdio. It then execs an intermediate
program that closes file descriptors inherited form the host applications and
ensure that signal handers are returned to their default disposition. The
intermediate program then launches your plugin server program.</p>

<p>The plugin API may be supported my numerous applications, meaning that your
plugin may be loaded into host applications with different architectures.
Attendant monitors your process even thought it might not be able to do
traditional process monitoring because the host application has employed
signals and is waiting on all child processes for its own process monitoring
needs.</p>

<p>You might be in a multi-threaded application, where forked proceses can only
make async-safe system calls, anything less is thread-unsafe. You might be in
an multi-process application, that has registered its own signal handlers,
and treats your child process as one of its own workers.  You don't have
control over signal handlers. You don't know who's going to reap your child
process. You don't know what file descriptors your child process will
inherit.</p>

<p>This required a lot of careful reading of man pages, so I've annotated the
code thurougly, in literate programming style, formatted for reading after
passing it though a fork of Docco I doctored to handle C's multi-line
comments. I'm going to remind myself now that the comments are supposed to
assist my recolection when the time comes to consider fork and exec once
again.</p>

<h3>Drop Off</h3>

<p>When we fork our server process, we are going to execve immediately. Assuming
the most fragile state possible, we will be sure not to make any system calls
that are not async-safe, allocate no memory, twiddle and mutexes.</p>

<p>At the time of writing, this code is indended for use on OS X, Linux and
Windows, to be dynamically linked into a running instance of Safari, Firefox
or Chrome. Here are the considerations for these environments.</p>

<p>Safari and Firefox have multi-threaded architectures, while Chrome has a
multi-process architecture. Fork and threads do not mix well. This creates
two sets of considerations.</p>

<p>For the multi-threaded architectures, fork can come as a surprise, distrubing
the state mutexes, stomping on the mutexes used to make traditional global
functions thread safe.</p>

<p>Chrome, on the other hand, is already launching processes. It has signal
handlers installed, and is waiting on process completion. It's attempts to
communicate with its child processes might be confused by additional child
processes that it didn't launch itself. Also, it might swallow signals that
we'll depend upon to monitor the server process.</p>

<p>The concerns raised by these architectures will be discussed and addressed in
the code below in the literate programming style.</p>

<p>We're going to program defensively, to isolate our server process as quickly
as possible, as completely as possible. We're not up for the challenge of</p>

<p>There is a third possible architecture which is the multi-fubar architecture
that has done all that it can to create a fragile environment for monitoring
child processes. We'll attempt to address some of these issues as well.</p>

<h3>From Down Below</h3>

<p>Mozilla has nsIProcess. This is a scriptable interface that allows add-on
developer to launch a process, so it is analogous to what we're doing here.
The Linux implementation of nsIProcess optionally establishes pipes for
stdio, but closes them if pipes are not desired, so that the forked process
does not inherit the browsers stdio handles. </p>

<p>Mozilla makes no attempt to close file any other handles. It has a an OS
abstraction library that sets optional FD_CLOEXEC on file handles that are
created based on an "inheritable" switch. Whether that switch is ever on is
difficult to determine, but it looks like no, so it would appear that file
handles are generally not inheritable in Mozilla, and closed on exec.</p>

<p>Safari WebKit doesn't appear to call FD_CLOEXEC when it opens files or
sockets, so we might have a few lying around.</p>

<p>Our multi-process architecture Google Chrome, might be caught off gaurd when
child processes are launched that are not its own, but it sets up the
environment for proper child handling. It chooses the file handles that a
child process will inherit carefully, but it seems like it does this right
before a fork, and all other handles are set to close on exec.</p>

<p>Our third architecture is the unknown future multi-headache one where
there is grief is optimum. That would be a host application that has a
phenominal number of file handles open and ready to inherit.</p>

<p>In any case, we're going to loop through all the open handles and close
the ones that are not stdio.</p>

<p>The worst case is we have an enormous number of open file hanldes that we
have to close. The best case is that we have none. The error case is that
here are no handles left to get the handles we need to close the handles.</p></td>
          <td class="code"><div class="highlight"><pre><div class="highlight"><pre></pre></div></td>
        </tr>
      
        <tr>
          <td class="docs"><p>The gang's all here. </p></td>
          <td class="code"><div class="highlight"><pre>
<span class="cp">#include &lt;errno.h&gt;</span>
<span class="cp">#include &lt;fcntl.h&gt;</span>
<span class="cp">#include &lt;limits.h&gt;</span>
<span class="cp">#include &lt;poll.h&gt;</span>
<span class="cp">#include &lt;pthread.h&gt;</span>
<span class="cp">#include &lt;signal.h&gt;</span>
<span class="cp">#include &lt;stdio.h&gt;</span>
<span class="cp">#include &lt;stdlib.h&gt;</span>
<span class="cp">#include &lt;string.h&gt;</span>
<span class="cp">#include &lt;time.h&gt;</span>
<span class="cp">#include &lt;unistd.h&gt;</span>
</pre></div></td>
        </tr>
      
        <tr>
          <td class="docs"><p>Local includes. </p></td>
          <td class="code"><div class="highlight"><pre>
<span class="cp">#include &quot;attendant.h&quot;</span>
<span class="cp">#include &quot;eintr.h&quot;</span>
<span class="cp">#include &quot;errors.h&quot;</span>
</pre></div></td>
        </tr>
      
        <tr>
          <td class="docs"><p>The abend handler will be called from a thread that is watching the process,
so if you supply a callback, be sure to be thread-safe.</p>

<p>You are probably going to restart the server process, which means that you'll
have to reinitialize your library to use it. Any variables visibile to both
this function and your library need to be guarded by a mutex.</p>

<p>And no, don't just make a variable volatile and think that will cover it. It
needs to be gaurded by a mutex to flush memory accross CPU cores.</p></td>
          <td class="code"><div class="highlight"><pre>
</pre></div></td>
        </tr>
      
        <tr>
          <td class="docs"><p>&#9824; </p></td>
          <td class="code"><div class="highlight"><pre>
<span class="k">typedef</span> <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">abend_handler_t</span><span class="p">)();</span>
</pre></div></td>
        </tr>
      
        <tr>
          <td class="docs"><h3>Global State</h3>

<p>We have a collection of conditions used to alert blocking stub functions of a
change in state in the server process.</p></td>
          <td class="code"><div class="highlight"><pre>
</pre></div></td>
        </tr>
      
        <tr>
          <td class="docs"><p>&#9824; </p></td>
          <td class="code"><div class="highlight"><pre>
<span class="k">struct</span> <span class="n">cond</span> <span class="p">{</span></pre></div></td>
        </tr>
      
        <tr>
          <td class="docs"><p>Server is running or it will never run again. </p></td>
          <td class="code"><div class="highlight"><pre>
  <span class="n">pthread_cond_t</span>  <span class="n">running</span><span class="p">;</span>  </pre></div></td>
        </tr>
      
        <tr>
          <td class="docs"><p>Server has shutdown. </p></td>
          <td class="code"><div class="highlight"><pre>
  <span class="n">pthread_cond_t</span>  <span class="n">shutdown</span><span class="p">;</span> </pre></div></td>
        </tr>
      
        <tr>
          <td class="docs"><p>Used for sake of timed wait. </p></td>
          <td class="code"><div class="highlight"><pre>
  <span class="n">pthread_cond_t</span>  <span class="n">getgpid</span><span class="p">;</span>  </pre></div></td>
        </tr>
      
        <tr>
          <td class="docs"><p>&mdash; </p></td>
          <td class="code"><div class="highlight"><pre>
<span class="p">};</span>

</pre></div></td>
        </tr>
      
        <tr>
          <td class="docs"><p>For testing we keep a trace log. This is not a production log. If this is
enabled during production, tracing will stop when the array of poitns is
filled. </p></td>
          <td class="code"><div class="highlight"><pre>
</pre></div></td>
        </tr>
      
        <tr>
          <td class="docs"></td>
          <td class="code"><div class="highlight"><pre>
<span class="cp">#ifdef _DEBUG</span>
<span class="k">struct</span> <span class="n">trace</span> <span class="p">{</span></pre></div></td>
        </tr>
      
        <tr>
          <td class="docs"><p>Each entry is a formatted string representing a trace point. </p></td>
          <td class="code"><div class="highlight"><pre>
  <span class="kt">char</span> <span class="o">*</span><span class="n">points</span><span class="p">[</span><span class="mi">256</span><span class="p">];</span></pre></div></td>
        </tr>
      
        <tr>
          <td class="docs"><p>The current count of log entries. </p></td>
          <td class="code"><div class="highlight"><pre>
  <span class="kt">int</span> <span class="n">count</span><span class="p">;</span></pre></div></td>
        </tr>
      
        <tr>
          <td class="docs"><p>Gaurd for thread-safe traceing. </p></td>
          <td class="code"><div class="highlight"><pre>
  <span class="n">pthread_mutex_t</span> <span class="n">mutex</span><span class="p">;</span>      
<span class="p">};</span>
<span class="cp">#endif</span>
</pre></div></td>
        </tr>
      
        <tr>
          <td class="docs"><p>The one and only process we watch. Static variables are gathered into this
structure so that when reading the code below, it is easy to see which are
static variables and which are local variables.</p></td>
          <td class="code"><div class="highlight"><pre>
</pre></div></td>
        </tr>
      
        <tr>
          <td class="docs"><p>&#9824; </p></td>
          <td class="code"><div class="highlight"><pre>
<span class="k">struct</span> <span class="n">process_t</span> <span class="p">{</span></pre></div></td>
        </tr>
      
        <tr>
          <td class="docs"><p>Absolute path to the relay program. </p></td>
          <td class="code"><div class="highlight"><pre>
  <span class="kt">char</span> <span class="o">*</span><span class="n">relay</span><span class="p">;</span></pre></div></td>
        </tr>
      
        <tr>
          <td class="docs"><p>Arguments to pass to relay program, starting with the absolute path to the
plugin server program. </p></td>
          <td class="code"><div class="highlight"><pre>
  <span class="kt">char</span> <span class="o">**</span><span class="n">argv</span><span class="p">;</span></pre></div></td>
        </tr>
      
        <tr>
          <td class="docs"><p>The file descriptor inherited by server process that when closed indicates
that the server process has died. </p></td>
          <td class="code"><div class="highlight"><pre>
  <span class="kt">int</span> <span class="n">canary</span><span class="p">;</span></pre></div></td>
        </tr>
      
        <tr>
          <td class="docs"><p>User supplied unexpected exit handler. </p></td>
          <td class="code"><div class="highlight"><pre>
  <span class="n">abend_handler_t</span> <span class="n">abend</span><span class="p">;</span></pre></div></td>
        </tr>
      
        <tr>
          <td class="docs"><p>SIGCHLD is not SIG_IGN so waitpid will block on specific pid. </p></td>
          <td class="code"><div class="highlight"><pre>
  <span class="kt">short</span> <span class="n">waitable</span><span class="p">;</span></pre></div></td>
        </tr>
      
        <tr>
          <td class="docs"><p>The process pid. </p></td>
          <td class="code"><div class="highlight"><pre>
  <span class="n">pid_t</span> <span class="n">pid</span><span class="p">;</span></pre></div></td>
        </tr>
      
        <tr>
          <td class="docs"><p>Server is running. </p></td>
          <td class="code"><div class="highlight"><pre>
  <span class="kt">short</span> <span class="n">running</span><span class="p">;</span></pre></div></td>
        </tr>
      
        <tr>
          <td class="docs"><p>The server is recovering from unexpected exit. </p></td>
          <td class="code"><div class="highlight"><pre>
  <span class="kt">short</span> <span class="n">restarting</span><span class="p">;</span></pre></div></td>
        </tr>
      
        <tr>
          <td class="docs"><p>Shutdown is pending and exit is expected. </p></td>
          <td class="code"><div class="highlight"><pre>
  <span class="kt">short</span> <span class="n">shutdown</span><span class="p">;</span></pre></div></td>
        </tr>
      
        <tr>
          <td class="docs"><p>A count of the number of times that the server has started and restarted.</p></td>
          <td class="code"><div class="highlight"><pre>
  <span class="kt">int</span> <span class="n">instance</span><span class="p">;</span></pre></div></td>
        </tr>
      
        <tr>
          <td class="docs"><p>The attendant error code for last thing that went wrong. </p></td>
          <td class="code"><div class="highlight"><pre>
  <span class="kt">int</span> <span class="n">last_error</span><span class="p">;</span></pre></div></td>
        </tr>
      
        <tr>
          <td class="docs"><p>The system error code for the last thing that went wrong. </p></td>
          <td class="code"><div class="highlight"><pre>
  <span class="kt">int</span> <span class="n">last_errno</span><span class="p">;</span></pre></div></td>
        </tr>
      
        <tr>
          <td class="docs"><p>Thread local storage key for thread local storage of instance count. </p></td>
          <td class="code"><div class="highlight"><pre>
  <span class="n">pthread_key_t</span> <span class="n">key</span><span class="p">;</span>          </pre></div></td>
        </tr>
      
        <tr>
          <td class="docs"><p>Once key for one time initializatin of thread local storage of instance count. </p></td>
          <td class="code"><div class="highlight"><pre>
  <span class="n">pthread_once_t</span> <span class="n">onceler</span><span class="p">;</span>     </pre></div></td>
        </tr>
      
        <tr>
          <td class="docs"><p>Gaurd process variables referenced by both the stub functions running in
the plugin threads and the server process management threads. </p></td>
          <td class="code"><div class="highlight"><pre>
  <span class="n">pthread_mutex_t</span> <span class="n">mutex</span><span class="p">;</span>      </pre></div></td>
        </tr>
      
        <tr>
          <td class="docs"><p>Collection of conditions. </p></td>
          <td class="code"><div class="highlight"><pre>
  <span class="k">struct</span> <span class="n">cond</span> <span class="n">cond</span><span class="p">;</span></pre></div></td>
        </tr>
      
        <tr>
          <td class="docs"><p>The server process launcher thread. </p></td>
          <td class="code"><div class="highlight"><pre>
  <span class="n">pthread_t</span> <span class="n">launcher</span><span class="p">;</span></pre></div></td>
        </tr>
      
        <tr>
          <td class="docs"><p>The server process reaper thread. </p></td>
          <td class="code"><div class="highlight"><pre>
  <span class="n">pthread_t</span> <span class="n">reaper</span><span class="p">;</span></pre></div></td>
        </tr>
      
        <tr>
          <td class="docs"><p>We create seven pipes, so we create an array of seven pipe pairs. We then
refer to the pipes by name in code using the defines below that map the
pipe name to a pipe index. </p></td>
          <td class="code"><div class="highlight"><pre>
  <span class="kt">int</span> <span class="n">pipes</span><span class="p">[</span><span class="mi">7</span><span class="p">][</span><span class="mi">2</span><span class="p">];</span>            </pre></div></td>
        </tr>
      
        <tr>
          <td class="docs"><p>Tracing variables. See above. </p></td>
          <td class="code"><div class="highlight"><pre>
<span class="cp">#ifdef _DEBUG</span>
  <span class="k">struct</span> <span class="n">trace</span> <span class="n">trace</span><span class="p">;</span>
<span class="cp">#endif</span></pre></div></td>
        </tr>
      
        <tr>
          <td class="docs"><p>&mdash; </p></td>
          <td class="code"><div class="highlight"><pre><span class="cp"></span>
<span class="p">};</span>
</pre></div></td>
        </tr>
      
        <tr>
          <td class="docs"><p>The variable structure for our once and only instance of the plugin
attendant. </p></td>
          <td class="code"><div class="highlight"><pre>
</pre></div></td>
        </tr>
      
        <tr>
          <td class="docs"><p>&mdash; </p></td>
          <td class="code"><div class="highlight"><pre>
<span class="k">static</span> <span class="k">struct</span> <span class="n">process_t</span> <span class="n">process</span><span class="p">;</span>
</pre></div></td>
        </tr>
      
        <tr>
          <td class="docs"><h3>Pipes</h3>

<p>The collection of pipes in the process structure is indexed using constants.
There are seven pipes. Three are the expected pipes for stdio. Attendant
makes use of the EPIPE error to detect that a child process has exited, or
that a pipe with the <code>FD_CLOEXEC</code> flag set was closed on exec when exec was
called. This is how we monitor our child process, because <code>waitpid</code> might be
disabled by the host application.</p></td>
          <td class="code"><div class="highlight"><pre>
</pre></div></td>
        </tr>
      
        <tr>
          <td class="docs"><p>One pipe for each io stream.</p></td>
          <td class="code"><div class="highlight"><pre>
</pre></div></td>
        </tr>
      
        <tr>
          <td class="docs"><p>&mdash; </p></td>
          <td class="code"><div class="highlight"><pre>
<span class="cp">#define PIPE_STDIN  0</span>
<span class="cp">#define PIPE_STDOUT 1</span>
<span class="cp">#define PIPE_STDERR 2</span>
</pre></div></td>
        </tr>
      
        <tr>
          <td class="docs"><p>The fork pipe reports a successful fork initialization. We listen to the fork
pipe for an error number, or a zero, or report if it closes mysteriously.</p></td>
          <td class="code"><div class="highlight"><pre>
</pre></div></td>
        </tr>
      
        <tr>
          <td class="docs"><p>&mdash; </p></td>
          <td class="code"><div class="highlight"><pre>
<span class="cp">#define PIPE_FORK   3</span>
</pre></div></td>
        </tr>
      
        <tr>
          <td class="docs"><p>The exec pipe reports a successful exec. It guards against a race condition
where we've forked but not execed, and the client library calls scram, which
sends a kill SIGKILL, but not to our server process, but to the fork process.
Not the end of the world, but I'd rather send a SIGTERM to the fork process,
instead of SIGKILL.</p></td>
          <td class="code"><div class="highlight"><pre>
</pre></div></td>
        </tr>
      
        <tr>
          <td class="docs"><p>&mdash; </p></td>
          <td class="code"><div class="highlight"><pre>
<span class="cp">#define PIPE_RELAY   4</span>
</pre></div></td>
        </tr>
      
        <tr>
          <td class="docs"><p>The reaper thread will listen to the canary pipe, the other end is held by
the running child server process. When the pipe closes and we get an <code>EPIPE</code>
error, it means the plugin server process has exited. This is how we monitor
the child server process without relying on <code>waitpid</code> being functional. </p></td>
          <td class="code"><div class="highlight"><pre>
</pre></div></td>
        </tr>
      
        <tr>
          <td class="docs"><p>&mdash; </p></td>
          <td class="code"><div class="highlight"><pre>
<span class="cp">#define PIPE_CANARY   5</span>
</pre></div></td>
        </tr>
      
        <tr>
          <td class="docs"><p>The reaper thread will poll the canary pipe above, listening for the library
server process exit. At the same time it will poll this instance pipe, which
is used by the plugin stub to wake the reaper thread and tell it to forcibly
retart the plugin server process. The plugin server process may have become
unresponsive, but may not have exited. The plugin stub will detect this as
IPC calls timeout, while the reaper thread can only detect exit.</p></td>
          <td class="code"><div class="highlight"><pre>
</pre></div></td>
        </tr>
      
        <tr>
          <td class="docs"><p>&mdash; </p></td>
          <td class="code"><div class="highlight"><pre>
<span class="cp">#define PIPE_REAPER   6</span>
</pre></div></td>
        </tr>
      
        <tr>
          <td class="docs"><p><code>stdio</code> &mdash; The standard I/O pipes do not change during the life time of
the plugin attendant. They are preserved across restarts by duping the parent
end file descriptors of a newly allocated pipe to the parent end file
descriptors of the previous pipe.  You can cache these values.</p>

<p>Because the system calls are thread safe, there is no need for
synchronization when reading or writing to a pipe. There are other issues to
sort out for the plugin developer, regarding multiplexing.</p>

<p>We reassign the parent end file descriptor using dup2.</p></td>
          <td class="code"><div class="highlight"><pre>
</pre></div></td>
        </tr>
      
        <tr>
          <td class="docs"><p>&#9824; </p></td>
          <td class="code"><div class="highlight"><pre>
<span class="k">static</span> <span class="n">pipe_t</span> <span class="nf">stdio</span><span class="p">(</span><span class="kt">int</span> <span class="n">pipe</span><span class="p">)</span>
<span class="p">{</span>
  <span class="k">return</span> <span class="n">process</span><span class="p">.</span><span class="n">pipes</span><span class="p">[</span><span class="n">pipe</span><span class="p">][</span><span class="n">pipe</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">?</span> <span class="mi">1</span> <span class="o">:</span> <span class="mi">0</span><span class="p">];</span>
<span class="p">}</span>
</pre></div></td>
        </tr>
      
        <tr>
          <td class="docs"><p>Process is one static structure, one process launched per library. It would
be easy enough to make this an API that has a handle, but if you did want to
run and watch a handful of server processes, it would better to make the
first process you launch that monitor, because you'll have complete control
over the environment, and your process monitoring strategy can take the shape
that best suits the needs of your application.</p>

<p>All we're trying to do here is get one process cleanly spun off form the host
application. We don't want the host application monitoring dozens of workers.</p>

<p>Link one of these to your library, and you're good to go.</p></td>
          <td class="code"><div class="highlight"><pre>
</pre></div></td>
        </tr>
      
        <tr>
          <td class="docs"><h3>Tracing</h3></td>
          <td class="code"><div class="highlight"><pre>
</pre></div></td>
        </tr>
      
        <tr>
          <td class="docs"><p>Format a logging message and write it to the log file. </p></td>
          <td class="code"><div class="highlight"><pre>
<span class="cp">#ifdef _DEBUG</span>
<span class="kt">void</span> <span class="nf">trace</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">function</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">point</span><span class="p">)</span> <span class="p">{</span>
  <span class="kt">char</span> <span class="n">buffer</span><span class="p">[</span><span class="mi">64</span><span class="p">];</span>
  <span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="n">pthread_mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">process</span><span class="p">.</span><span class="n">trace</span><span class="p">.</span><span class="n">mutex</span><span class="p">);</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">process</span><span class="p">.</span><span class="n">trace</span><span class="p">.</span><span class="n">count</span> <span class="o">&lt;</span> <span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">buffer</span><span class="p">)</span> <span class="o">/</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">char</span><span class="p">))</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">sprintf</span><span class="p">(</span><span class="n">buffer</span><span class="p">,</span> <span class="s">&quot;[%s/%s]&quot;</span><span class="p">,</span> <span class="n">function</span><span class="p">,</span> <span class="n">point</span><span class="p">);</span></pre></div></td>
        </tr>
      
        <tr>
          <td class="docs"><p>At times, I'll insert a <code>fprintf(stderr, "%s\n", buffer);</code> right here to see
what's happening as it happens. </p></td>
          <td class="code"><div class="highlight"><pre>
    <span class="n">process</span><span class="p">.</span><span class="n">trace</span><span class="p">.</span><span class="n">points</span><span class="p">[</span><span class="n">process</span><span class="p">.</span><span class="n">trace</span><span class="p">.</span><span class="n">count</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">strdup</span><span class="p">(</span><span class="n">buffer</span><span class="p">);</span>
  <span class="p">}</span>
  <span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="n">pthread_mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">process</span><span class="p">.</span><span class="n">trace</span><span class="p">.</span><span class="n">mutex</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">char</span><span class="o">**</span> <span class="nf">tracepoints</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">return</span> <span class="n">process</span><span class="p">.</span><span class="n">trace</span><span class="p">.</span><span class="n">points</span><span class="p">;</span>
<span class="p">}</span>
<span class="cp">#else</span>
<span class="cp">#define trace(function, breakpoint) ((void)0)</span>
<span class="cp">#endif</span>
</pre></div></td>
        </tr>
      
        <tr>
          <td class="docs"><h3>Initialization</h3></td>
          <td class="code"><div class="highlight"><pre>
</pre></div></td>
        </tr>
      
        <tr>
          <td class="docs"><p>Test the given condition and if it is true, record the given plugin attendant
error code and goto the given label. The label will mark an exit point for
the function, were cleanup will be performed. </p></td>
          <td class="code"><div class="highlight"><pre>
<span class="cp">#define FAIL(cond, message, label) \</span>
<span class="cp">  do { \</span>
<span class="cp">    if (cond) { \</span>
<span class="cp">      set_error(message); \</span>
<span class="cp">      goto label; \</span>
<span class="cp">    } \</span>
<span class="cp">  } while (0)</span>
</pre></div></td>
        </tr>
      
        <tr>
          <td class="docs"><p>Does nothing. Launched at initialization using the reaper thread handle, so
that the initial launcher has a reaper thread to join. </p></td>
          <td class="code"><div class="highlight"><pre>
<span class="k">static</span> <span class="kt">void</span><span class="o">*</span> <span class="nf">kickoff</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>
</pre></div></td>
        </tr>
      
        <tr>
          <td class="docs"><p>Close a pipe if it is not already closed. </p></td>
          <td class="code"><div class="highlight"><pre>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">close_pipe</span><span class="p">(</span><span class="kt">int</span> <span class="n">pipeno</span><span class="p">,</span> <span class="kt">int</span> <span class="n">direction</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">process</span><span class="p">.</span><span class="n">pipes</span><span class="p">[</span><span class="n">pipeno</span><span class="p">][</span><span class="n">direction</span><span class="p">]</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">close</span><span class="p">(</span><span class="n">process</span><span class="p">.</span><span class="n">pipes</span><span class="p">[</span><span class="n">pipeno</span><span class="p">][</span><span class="n">direction</span><span class="p">]);</span>
    <span class="n">process</span><span class="p">.</span><span class="n">pipes</span><span class="p">[</span><span class="n">pipeno</span><span class="p">][</span><span class="n">direction</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></div></td>
        </tr>
      
        <tr>
          <td class="docs"><p>Record the given plugin attendant error code along with the current system
error number. </p></td>
          <td class="code"><div class="highlight"><pre>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">set_error</span><span class="p">(</span><span class="kt">int</span> <span class="n">error</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">process</span><span class="p">.</span><span class="n">last_error</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">process</span><span class="p">.</span><span class="n">last_error</span> <span class="o">=</span> <span class="n">error</span><span class="p">;</span>
    <span class="n">process</span><span class="p">.</span><span class="n">last_errno</span> <span class="o">=</span> <span class="n">errno</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></div></td>
        </tr>
      
        <tr>
          <td class="docs"><p><code>initalize</code> &mdash; Called as the dynamic library is loaded. Must be called
before the plugin server process can be started.</p></td>
          <td class="code"><div class="highlight"><pre>
</pre></div></td>
        </tr>
      
        <tr>
          <td class="docs"><p>&#9824; </p></td>
          <td class="code"><div class="highlight"><pre>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">initalize</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">relay</span><span class="p">,</span> <span class="kt">int</span> <span class="n">canary</span><span class="p">)</span>
<span class="p">{</span>
  <span class="k">struct</span> <span class="n">sigaction</span> <span class="n">sigchld</span><span class="p">;</span>
  <span class="n">pthread_condattr_t</span> <span class="n">attr</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">pipeno</span><span class="p">,</span> <span class="n">err</span><span class="p">;</span>
</pre></div></td>
        </tr>
      
        <tr>
          <td class="docs"><p>The user gets to chose the canary file descriptor on UNIX. </p></td>
          <td class="code"><div class="highlight"><pre>
  <span class="n">process</span><span class="p">.</span><span class="n">canary</span> <span class="o">=</span> <span class="n">canary</span><span class="p">;</span>
</pre></div></td>
        </tr>
      
        <tr>
          <td class="docs"><p>Take note of the location of the relay program. </p></td>
          <td class="code"><div class="highlight"><pre>
  <span class="n">process</span><span class="p">.</span><span class="n">relay</span> <span class="o">=</span> <span class="n">strdup</span><span class="p">(</span><span class="n">relay</span><span class="p">);</span>
</pre></div></td>
        </tr>
      
        <tr>
          <td class="docs"><p>Initialize the pipes to -1, so we know that they are not open. </p></td>
          <td class="code"><div class="highlight"><pre>
  <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="n">PIPE_STDIN</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">PIPE_REAPER</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">process</span><span class="p">.</span><span class="n">pipes</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">process</span><span class="p">.</span><span class="n">pipes</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
  <span class="p">}</span>
</pre></div></td>
        </tr>
      
        <tr>
          <td class="docs"><p>Create our mutex and signaling device. </p></td>
          <td class="code"><div class="highlight"><pre>
  <span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="n">pthread_mutex_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">process</span><span class="p">.</span><span class="n">mutex</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
</pre></div></td>
        </tr>
      
        <tr>
          <td class="docs"><p>Initialize thread conditions. These are used to by threads to wait for
another thread to change the state of static variables.</p>

<p>For Linux, we set a condition attribute <code>CLOCK_MONOTONIC</code>, which causes the
condition to use a monotonic clock when it times the timeout for a wait.</p>

<p>A monotonic clock is one that always increases at a steady rate,
independent of the system clock, so that if someone sets the the system
clock back an hour while we're waiting on a 250 millisecond timeout, we
don't end up waiting for that extra hour.</p>

<p>To get system clock safe timeouts on Darwin, we use a different strategy.
See <code>pthread_cond_waitforabit</code>.</p></td>
          <td class="code"><div class="highlight"><pre>
</pre></div></td>
        </tr>
      
        <tr>
          <td class="docs"><p>Initialize thread conditions. </p></td>
          <td class="code"><div class="highlight"><pre>
  <span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="n">pthread_condattr_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">attr</span><span class="p">);</span>

<span class="cp">#if !defined (_POSIX_CLOCK_SELECTION)</span>
<span class="cp"># define _POSIX_CLOCK_SELECTION (-1)</span>
<span class="cp">#endif </span>
<span class="cp">#if (_POSIX_CLOCK_SELECTION &gt;= 0)</span>
  <span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="n">pthread_condattr_setclock</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">attr</span><span class="p">,</span> <span class="n">CLOCK_MONOTONIC</span><span class="p">);</span>
<span class="cp">#endif</span>

  <span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="n">pthread_cond_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">process</span><span class="p">.</span><span class="n">cond</span><span class="p">.</span><span class="n">running</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">attr</span><span class="p">);</span>
  <span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="n">pthread_cond_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">process</span><span class="p">.</span><span class="n">cond</span><span class="p">.</span><span class="n">shutdown</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">attr</span><span class="p">);</span>
  <span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="n">pthread_cond_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">process</span><span class="p">.</span><span class="n">cond</span><span class="p">.</span><span class="n">getgpid</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">attr</span><span class="p">);</span>

  <span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="n">pthread_condattr_destroy</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">attr</span><span class="p">);</span>

</pre></div></td>
        </tr>
      
        <tr>
          <td class="docs"><p>If the state of SIGCHLD is SIG_IGN the host application wants the kernel to
take care of zombies, and waitpid is usless for our purposes.</p>

<p>We need a waitpid that will block until the child process exits. When
SIG_IGN is in play, waitpid blocks until all children exit, and then it
returns an ECHILD error. We're not monitoring our server process if that is
the case.</p>

<p>It is far too presumptuous for a plugin to fix this by setting a signal
handler for SIGCHLD. That is, an application that was counting on the
kernel to reap children would probably not notice if we installed a
canonical SIGCHLD handler that reaped children, but its not our place. Of
course, setting SIGCHLD to SIG_DFT would certianly make zombies of any
children created by the host application that expects them to be reaped.</p>

<p>We take not of the state here. If SIGCHLD is ignored, we won't call
<code>waitpid</code> at exit, but intead poll using the <code>pid</code>.</p></td>
          <td class="code"><div class="highlight"><pre>
</pre></div></td>
        </tr>
      
        <tr>
          <td class="docs"><p>Determine if the SIGCHILD is ignored. </p></td>
          <td class="code"><div class="highlight"><pre>
  <span class="n">sigaction</span><span class="p">(</span><span class="n">SIGCHLD</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sigchld</span><span class="p">);</span>
  <span class="n">process</span><span class="p">.</span><span class="n">waitable</span> <span class="o">=</span> <span class="n">sigchld</span><span class="p">.</span><span class="n">sa_handler</span> <span class="o">!=</span> <span class="n">SIG_IGN</span><span class="p">;</span>
</pre></div></td>
        </tr>
      
        <tr>
          <td class="docs"><p>The plugin stub will wait for ready, so instance will be one or more before
retry is called. </p></td>
          <td class="code"><div class="highlight"><pre>
  <span class="n">process</span><span class="p">.</span><span class="n">instance</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</pre></div></td>
        </tr>
      
        <tr>
          <td class="docs"><p>Nope. Only after the initial call to start. </p></td>
          <td class="code"><div class="highlight"><pre>
  <span class="n">process</span><span class="p">.</span><span class="n">running</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</pre></div></td>
        </tr>
      
        <tr>
          <td class="docs"><p>Ensure that the launcher thread has a reaper thread to join. </p></td>
          <td class="code"><div class="highlight"><pre>
  <span class="n">pthread_create</span><span class="p">(</span><span class="o">&amp;</span><span class="n">process</span><span class="p">.</span><span class="n">reaper</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">kickoff</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
</pre></div></td>
        </tr>
      
        <tr>
          <td class="docs"><p>We will preserve the same file descriptors on the plugin stub end of the
stdio pipes between restarts. The launcher thread is going to expect a
previous set, so we create it here to get the ball rolling. </p></td>
          <td class="code"><div class="highlight"><pre>
  <span class="k">for</span> <span class="p">(</span><span class="n">pipeno</span> <span class="o">=</span> <span class="n">PIPE_STDIN</span><span class="p">;</span> <span class="n">pipeno</span> <span class="o">&lt;=</span> <span class="n">PIPE_STDERR</span><span class="p">;</span> <span class="n">pipeno</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">err</span> <span class="o">=</span> <span class="n">pipe</span><span class="p">(</span><span class="n">process</span><span class="p">.</span><span class="n">pipes</span><span class="p">[</span><span class="n">pipeno</span><span class="p">]);</span>
    <span class="n">FAIL</span><span class="p">(</span><span class="n">err</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">INITIALIZE_CANNOT_CREATE_STDIN_PIPE</span> <span class="o">+</span> <span class="n">pipeno</span><span class="p">,</span> <span class="n">fail</span><span class="p">);</span>
  <span class="p">}</span>
</pre></div></td>
        </tr>
      
        <tr>
          <td class="docs"><p>We can close the file descriptors of the plugin server side now. We're not
going to actually use these particular pipes. </p></td>
          <td class="code"><div class="highlight"><pre>
  <span class="n">close_pipe</span><span class="p">(</span><span class="n">PIPE_STDIN</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
  <span class="n">close_pipe</span><span class="p">(</span><span class="n">PIPE_STDOUT</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
  <span class="n">close_pipe</span><span class="p">(</span><span class="n">PIPE_STDERR</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
</pre></div></td>
        </tr>
      
        <tr>
          <td class="docs"><p>Create the instance pipe, which will remain open until the plugin attendant
is destroyed. </p></td>
          <td class="code"><div class="highlight"><pre>
  <span class="n">err</span> <span class="o">=</span> <span class="n">pipe</span><span class="p">(</span><span class="n">process</span><span class="p">.</span><span class="n">pipes</span><span class="p">[</span><span class="n">PIPE_REAPER</span><span class="p">]);</span>
  <span class="n">FAIL</span><span class="p">(</span><span class="n">err</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">INITIALIZE_CANNOT_CREATE_REAPER_PIPE</span><span class="p">,</span> <span class="n">fail</span><span class="p">);</span>
</pre></div></td>
        </tr>
      
        <tr>
          <td class="docs"><p>No child process should inherit the instance pipe. </p></td>
          <td class="code"><div class="highlight"><pre>
  <span class="n">fcntl</span><span class="p">(</span><span class="n">process</span><span class="p">.</span><span class="n">pipes</span><span class="p">[</span><span class="n">PIPE_REAPER</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="n">F_SETFD</span><span class="p">,</span> <span class="n">FD_CLOEXEC</span><span class="p">);</span>
  <span class="n">fcntl</span><span class="p">(</span><span class="n">process</span><span class="p">.</span><span class="n">pipes</span><span class="p">[</span><span class="n">PIPE_REAPER</span><span class="p">][</span><span class="mi">1</span><span class="p">],</span> <span class="n">F_SETFD</span><span class="p">,</span> <span class="n">FD_CLOEXEC</span><span class="p">);</span>
</pre></div></td>
        </tr>
      
        <tr>
          <td class="docs"><p>Initialize tracing mutex. </p></td>
          <td class="code"><div class="highlight"><pre>
<span class="cp">#ifdef _DEBUG</span>
  <span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="n">pthread_mutex_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">process</span><span class="p">.</span><span class="n">trace</span><span class="p">.</span><span class="n">mutex</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
<span class="cp">#endif</span>

  <span class="n">trace</span><span class="p">(</span><span class="s">&quot;initialize&quot;</span><span class="p">,</span> <span class="s">&quot;success&quot;</span><span class="p">);</span>
</pre></div></td>
        </tr>
      
        <tr>
          <td class="docs"><p>TODO: What is success? </p></td>
          <td class="code"><div class="highlight"><pre>
  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">fail:</span></pre></div></td>
        </tr>
      
        <tr>
          <td class="docs"><p>If we fail, then we close any pipes we might have opened. </p></td>
          <td class="code"><div class="highlight"><pre>
  <span class="n">close_pipe</span><span class="p">(</span><span class="n">PIPE_STDIN</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
  <span class="n">close_pipe</span><span class="p">(</span><span class="n">PIPE_STDIN</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>

  <span class="n">close_pipe</span><span class="p">(</span><span class="n">PIPE_STDOUT</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
  <span class="n">close_pipe</span><span class="p">(</span><span class="n">PIPE_STDOUT</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>

  <span class="n">close_pipe</span><span class="p">(</span><span class="n">PIPE_STDERR</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
  <span class="n">close_pipe</span><span class="p">(</span><span class="n">PIPE_STDERR</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>

  <span class="n">close_pipe</span><span class="p">(</span><span class="n">PIPE_REAPER</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
  <span class="n">close_pipe</span><span class="p">(</span><span class="n">PIPE_REAPER</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>

  <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span></pre></div></td>
        </tr>
      
        <tr>
          <td class="docs"><p>&mdash; </p></td>
          <td class="code"><div class="highlight"><pre>
<span class="p">}</span>
</pre></div></td>
        </tr>
      
        <tr>
          <td class="docs"><p>If someone or something, say NTP, resets the system clock while we are
waiting on a condition, the outcome could be an aburdly long wait, hanging
the application. </p>

<p>With pthreads, Linux has an option to use CLOCK_MONOTONIC with the pthread
condition. A monotonic clock is  a clock that always advances at a steady
rate, even if the system clock is reset.</p>

<p>Both Darwin and Linux have a monotonic clock, but Darwin does not allow you
to use it with pthreads, only Linux. We use the system clock.</p>

<p>Darwin has a non-portable function that will do a relative wait. We implement
a function here that is a wrapper around that function, and an analogous
implementation in Linux. The pthread conditions have their clock set to the
CLOCK_MONOTONIC clock when they are created above.</p>

<p>TK Move these notes on suprious wakeup.</p>

<p>Returns the number of milliseconds remaining for the timeout. The condition
may be signaled before the timeout, due to <a href="https://groups.google.com/group/comp.programming.threads/msg/bb8299804652fdd7">suprious
wakeup</a>,
but the conditions that caused the caller to wait may not have changed. The
caller may want to wait for the remaining amount of time, instead of trying
for the the full amount.</p>

<p>We wouldn't worry about this if a timeout meant that the user would recheck
invariants, as is the case for the reaper thread call of this function, but
for the call to this function from done, the timeout signifies the amount of
time that the </p></td>
          <td class="code"><div class="highlight"><pre>
<span class="kt">void</span> <span class="nf">pthread_cond_waitforabit</span><span class="p">(</span><span class="n">pthread_cond_t</span> <span class="o">*</span><span class="n">cond</span><span class="p">,</span> <span class="n">pthread_mutex_t</span> <span class="o">*</span><span class="n">mutex</span><span class="p">,</span>
    <span class="kt">int</span> <span class="n">millis</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">struct</span> <span class="n">timespec</span> <span class="n">timespec</span><span class="p">;</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">millis</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
<span class="cp">#ifdef __MACH__</span>
    <span class="n">timespec</span><span class="p">.</span><span class="n">tv_sec</span> <span class="o">=</span> <span class="n">millis</span> <span class="o">/</span> <span class="mi">1000</span><span class="p">;</span>
    <span class="n">timespec</span><span class="p">.</span><span class="n">tv_nsec</span> <span class="o">=</span> <span class="p">(</span><span class="n">millis</span> <span class="o">%</span> <span class="mi">1000</span><span class="p">)</span> <span class="o">*</span> <span class="mi">1000000</span><span class="p">;</span>
    <span class="n">pthread_cond_timedwait_relative_np</span><span class="p">(</span><span class="n">cond</span><span class="p">,</span> <span class="n">mutex</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">timespec</span><span class="p">);</span>
<span class="cp">#else</span>
    <span class="n">clock_gettime</span><span class="p">(</span><span class="n">CLOCK_MONOTONIC</span><span class="p">,</span> <span class="n">timespec</span><span class="p">);</span>
    <span class="n">timespec</span><span class="p">.</span><span class="n">tv_nsec</span> <span class="o">+=</span> <span class="n">millis</span>  <span class="o">*</span> <span class="mi">1000000</span><span class="p">;</span>
    <span class="n">timespec</span><span class="p">.</span><span class="n">tv_sec</span> <span class="o">+=</span> <span class="n">timespec</span><span class="p">.</span><span class="n">tv_nsec</span> <span class="o">/</span> <span class="mi">1000000000</span><span class="p">;</span>
    <span class="n">timespec</span><span class="p">.</span><span class="n">tv_nsec</span> <span class="o">+=</span> <span class="n">timespec</span><span class="p">.</span><span class="n">tv_nsec</span> <span class="o">%</span> <span class="mi">1000000000</span><span class="p">;</span>
    <span class="n">pthread_cond_timedwait</span><span class="p">(</span><span class="n">cond</span><span class="p">,</span> <span class="n">mutex</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">timespec</span><span class="p">);</span>
<span class="cp">#endif</span>
  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
    <span class="n">pthread_cond_wait</span><span class="p">(</span><span class="n">cond</span><span class="p">,</span> <span class="n">mutex</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></div></td>
        </tr>
      
        <tr>
          <td class="docs"><h3>Start</h3></td>
          <td class="code"><div class="highlight"><pre>
</pre></div></td>
        </tr>
      
        <tr>
          <td class="docs"><p>The start function calls the launch function. </p></td>
          <td class="code"><div class="highlight"><pre>
<span class="k">static</span> <span class="kt">void</span><span class="o">*</span> <span class="n">launch</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">);</span></pre></div></td>
        </tr>
      
        <tr>
          <td class="docs"><p>The launch function calls the reap function. </p></td>
          <td class="code"><div class="highlight"><pre>
<span class="k">static</span> <span class="kt">void</span><span class="o">*</span> <span class="n">reap</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">);</span></pre></div></td>
        </tr>
      
        <tr>
          <td class="docs"><p>Called by start, launch and reap. </p></td>
          <td class="code"><div class="highlight"><pre>
<span class="k">static</span> <span class="kt">void</span> <span class="n">signal_termination</span><span class="p">();</span>
</pre></div></td>
        </tr>
      
        <tr>
          <td class="docs"><p>Free the copy we made of the plugin server program name and arguments to pass
to the to the plugin server process.</p>

<p>The second argument to our relay program is the status pipe file descriptor
number. We don't know that number when we make our copy of the client
supplied arguments, so we leave it null. We always have at least four
arguments in the array, so we can safely skip the second argument when it is
null, because it can never be the array terminator.</p></td>
          <td class="code"><div class="highlight"><pre>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">free_argv</span><span class="p">()</span> <span class="p">{</span>
  <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">process</span><span class="p">.</span><span class="n">argv</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">process</span><span class="p">.</span><span class="n">argv</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">||</span> <span class="n">i</span> <span class="o">==</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">free</span><span class="p">(</span><span class="n">process</span><span class="p">.</span><span class="n">argv</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
      <span class="n">process</span><span class="p">.</span><span class="n">argv</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></div></td>
        </tr>
      
        <tr>
          <td class="docs"><p>Close all open pipes, except for the instance pipe and the plugin stub side
of the stdio pipes. The reaper pipe is never shared with children and lives
for the life of the plugin attendant. We keep the same file descriptor for
the plugin stub side of stdio between restarts, so that the plugin stub can
cache the file descriptors.</p></td>
          <td class="code"><div class="highlight"><pre>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">close_pipes</span><span class="p">()</span> <span class="p">{</span>
  <span class="kt">int</span> <span class="n">pipeno</span><span class="p">;</span>
  <span class="n">close_pipe</span><span class="p">(</span><span class="n">PIPE_STDIN</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
  <span class="n">close_pipe</span><span class="p">(</span><span class="n">PIPE_STDOUT</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
  <span class="n">close_pipe</span><span class="p">(</span><span class="n">PIPE_STDERR</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
  <span class="k">for</span> <span class="p">(</span><span class="n">pipeno</span> <span class="o">=</span> <span class="n">PIPE_FORK</span><span class="p">;</span> <span class="n">pipeno</span> <span class="o">&lt;=</span> <span class="n">PIPE_CANARY</span><span class="p">;</span> <span class="n">pipeno</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">close_pipe</span><span class="p">(</span><span class="n">pipeno</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
    <span class="n">close_pipe</span><span class="p">(</span><span class="n">pipeno</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></div></td>
        </tr>
      
        <tr>
          <td class="docs"><p>The <code>start</code> function is called first at library load, then subsequently from
the client provided abnormal exit handler. The client can choose to launch
the plugin server process with different arguments each time.</p>

<p>You can only call this once at library load from outside of the abend
handler. After calling this once from outside, the function must only be
called from within the abend handler in the thread that invokes the abend
handler. You can assign new arguments and abend handlers at each restart.</p>

<p>We could assert that with thread local storage for the reaper thread, and
passing instance numbers through the launcher thread, but we won't.</p></td>
          <td class="code"><div class="highlight"><pre>
</pre></div></td>
        </tr>
      
        <tr>
          <td class="docs"><p>&mdash; </p></td>
          <td class="code"><div class="highlight"><pre>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">start</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">path</span><span class="p">,</span> <span class="kt">char</span> <span class="k">const</span><span class="o">*</span> <span class="n">argv</span><span class="p">[],</span> <span class="n">abend_handler_t</span> <span class="n">abend</span><span class="p">)</span>
<span class="p">{</span>
  <span class="kt">int</span> <span class="n">err</span><span class="p">,</span> <span class="n">argc</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">running</span><span class="p">;</span>
  <span class="kt">size_t</span> <span class="n">size</span><span class="p">;</span>
</pre></div></td>
        </tr>
      
        <tr>
          <td class="docs"><p>Otherwise, what's the point? </p></td>
          <td class="code"><div class="highlight"><pre>
  <span class="n">FAIL</span><span class="p">(</span><span class="n">abend</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">START_ABEND_REQUIRED</span><span class="p">,</span> <span class="n">fail</span><span class="p">);</span>
  <span class="n">process</span><span class="p">.</span><span class="n">abend</span> <span class="o">=</span> <span class="n">abend</span><span class="p">;</span>
</pre></div></td>
        </tr>
      
        <tr>
          <td class="docs"><p>Assert that we're not being called while the one and only plugin server
process is already running. You're not calling the addendant functions in
the correct order.</p></td>
          <td class="code"><div class="highlight"><pre>
  <span class="n">pthread_mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">process</span><span class="p">.</span><span class="n">mutex</span><span class="p">);</span>
  <span class="n">running</span> <span class="o">=</span> <span class="n">process</span><span class="p">.</span><span class="n">running</span><span class="p">;</span>
  <span class="n">pthread_mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">process</span><span class="p">.</span><span class="n">mutex</span><span class="p">);</span>

  <span class="n">FAIL</span><span class="p">(</span><span class="n">running</span><span class="p">,</span> <span class="n">START_ALREADY_RUNNING</span><span class="p">,</span> <span class="n">fail</span><span class="p">);</span>
</pre></div></td>
        </tr>
      
        <tr>
          <td class="docs"><p>Reset our error codes and increment the instance count. </p></td>
          <td class="code"><div class="highlight"><pre>
  <span class="n">pthread_mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">process</span><span class="p">.</span><span class="n">mutex</span><span class="p">);</span>
  <span class="n">process</span><span class="p">.</span><span class="n">last_error</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="n">process</span><span class="p">.</span><span class="n">last_errno</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="n">process</span><span class="p">.</span><span class="n">instance</span><span class="o">++</span><span class="p">;</span>
  <span class="n">pthread_mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">process</span><span class="p">.</span><span class="n">mutex</span><span class="p">);</span>
</pre></div></td>
        </tr>
      
        <tr>
          <td class="docs"><p>Close any pipes that might still be open. </p></td>
          <td class="code"><div class="highlight"><pre>
  <span class="n">close_pipes</span><span class="p">();</span>
</pre></div></td>
        </tr>
      
        <tr>
          <td class="docs"><p>Count the number of arguments to the plugin server program. </p></td>
          <td class="code"><div class="highlight"><pre>
  <span class="k">for</span> <span class="p">(</span><span class="n">argc</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">argv</span><span class="p">[</span><span class="n">argc</span><span class="p">];</span> <span class="n">argc</span><span class="o">++</span><span class="p">);</span>
</pre></div></td>
        </tr>
      
        <tr>
          <td class="docs"><p>Create an array to store the arguments passed to the relay program. </p></td>
          <td class="code"><div class="highlight"><pre>
  <span class="n">size</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">argc</span> <span class="o">+</span> <span class="mi">5</span><span class="p">);</span>
  <span class="n">process</span><span class="p">.</span><span class="n">argv</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="n">size</span><span class="p">);</span>
  <span class="n">FAIL</span><span class="p">(</span><span class="o">!</span><span class="n">process</span><span class="p">.</span><span class="n">argv</span><span class="p">,</span> <span class="n">START_CANNOT_MALLOC</span><span class="p">,</span> <span class="n">fail</span><span class="p">);</span>
  <span class="n">memset</span><span class="p">(</span><span class="n">process</span><span class="p">.</span><span class="n">argv</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">size</span><span class="p">);</span>
</pre></div></td>
        </tr>
      
        <tr>
          <td class="docs"><p>The arguments to the relay program are name of the plugin process program
and the plugin process program arguments. We copy those values into the
null terminated arguments array. The first argument is the file descriptor
number for the status pipe, which we've not yet created, so leave that
<code>NULL</code>. </p></td>
          <td class="code"><div class="highlight"><pre>
  <span class="n">process</span><span class="p">.</span><span class="n">argv</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">strdup</span><span class="p">(</span><span class="n">process</span><span class="p">.</span><span class="n">relay</span><span class="p">);</span>
  <span class="n">process</span><span class="p">.</span><span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
  <span class="n">process</span><span class="p">.</span><span class="n">argv</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="mi">32</span><span class="p">);</span>
  <span class="n">FAIL</span><span class="p">(</span><span class="n">process</span><span class="p">.</span><span class="n">argv</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">START_CANNOT_MALLOC</span><span class="p">,</span> <span class="n">fail</span><span class="p">);</span>
  <span class="n">sprintf</span><span class="p">(</span><span class="n">process</span><span class="p">.</span><span class="n">argv</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="s">&quot;%d&quot;</span><span class="p">,</span> <span class="n">process</span><span class="p">.</span><span class="n">canary</span><span class="p">);</span>
  <span class="n">process</span><span class="p">.</span><span class="n">argv</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="n">strdup</span><span class="p">(</span><span class="n">path</span><span class="p">);</span>
  <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">argc</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">process</span><span class="p">.</span><span class="n">argv</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="n">strdup</span><span class="p">(</span><span class="n">argv</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
    <span class="n">FAIL</span><span class="p">(</span><span class="n">process</span><span class="p">.</span><span class="n">argv</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">4</span><span class="p">]</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">START_CANNOT_MALLOC</span><span class="p">,</span> <span class="n">fail</span><span class="p">);</span>
  <span class="p">}</span>
  <span class="n">process</span><span class="p">.</span><span class="n">argv</span><span class="p">[</span><span class="n">argc</span> <span class="o">+</span> <span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
</pre></div></td>
        </tr>
      
        <tr>
          <td class="docs"><p>Create a launcher thread. </p></td>
          <td class="code"><div class="highlight"><pre>
  <span class="n">err</span> <span class="o">=</span> <span class="n">pthread_create</span><span class="p">(</span><span class="o">&amp;</span><span class="n">process</span><span class="p">.</span><span class="n">launcher</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">launch</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
  <span class="n">FAIL</span><span class="p">(</span><span class="n">err</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">START_CANNOT_SPAWN_THREAD</span><span class="p">,</span> <span class="n">fail</span><span class="p">);</span>

  <span class="n">trace</span><span class="p">(</span><span class="s">&quot;start&quot;</span><span class="p">,</span> <span class="s">&quot;success&quot;</span><span class="p">);</span>

  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span></pre></div></td>
        </tr>
      
        <tr>
          <td class="docs"><p>TODO Do we signal_termination here? Yes. Sort this out. </p></td>
          <td class="code"><div class="highlight"><pre>
<span class="nl">fail:</span>
  <span class="n">free_argv</span><span class="p">();</span>
  <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>
</pre></div></td>
        </tr>
      
        <tr>
          <td class="docs"><h3>Launch</h3></td>
          <td class="code"><div class="highlight"><pre>
</pre></div></td>
        </tr>
      
        <tr>
          <td class="docs"><p>Recycle the file descriptors on the plugin stub end of the stdio pipes. We
create a pipe in a temporary variable. Duplicate the plugin stub end of the
pipe, assigning it the file descriptor of the previous plugin stub file
descriptor. We then close the temporary plugin stub end file descriptor and
record the plugin server process end in our static process structure. </p></td>
          <td class="code"><div class="highlight"><pre>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">recycle</span><span class="p">(</span><span class="kt">int</span> <span class="n">pipeno</span><span class="p">,</span> <span class="kt">int</span> <span class="n">parent</span><span class="p">)</span> <span class="p">{</span>
  <span class="kt">int</span> <span class="n">temp</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">child</span> <span class="o">=</span> <span class="n">parent</span> <span class="o">^</span> <span class="mi">1</span><span class="p">,</span> <span class="n">err</span><span class="p">;</span>
  <span class="n">err</span> <span class="o">=</span> <span class="n">pipe</span><span class="p">(</span><span class="n">temp</span><span class="p">);</span>
  <span class="n">FAIL</span><span class="p">(</span><span class="n">err</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">LAUNCH_CANNOT_CREATE_STDIN_PIPE</span> <span class="o">+</span> <span class="n">pipeno</span><span class="p">,</span> <span class="n">fail</span><span class="p">);</span>
  <span class="n">HANDLE_EINTR</span><span class="p">(</span><span class="n">dup2</span><span class="p">(</span><span class="n">temp</span><span class="p">[</span><span class="n">parent</span><span class="p">],</span> <span class="n">process</span><span class="p">.</span><span class="n">pipes</span><span class="p">[</span><span class="n">pipeno</span><span class="p">][</span><span class="n">parent</span><span class="p">]),</span> <span class="n">err</span><span class="p">);</span>
  <span class="n">HANDLE_EINTR</span><span class="p">(</span><span class="n">close</span><span class="p">(</span><span class="n">temp</span><span class="p">[</span><span class="n">parent</span><span class="p">]),</span> <span class="n">err</span><span class="p">);</span>
  <span class="n">process</span><span class="p">.</span><span class="n">pipes</span><span class="p">[</span><span class="n">pipeno</span><span class="p">][</span><span class="n">child</span><span class="p">]</span> <span class="o">=</span> <span class="n">temp</span><span class="p">[</span><span class="n">child</span><span class="p">];</span>
<span class="nl">fail:</span>
  <span class="k">return</span> <span class="n">err</span><span class="p">;</span> 
<span class="p">}</span>
</pre></div></td>
        </tr>
      
        <tr>
          <td class="docs"><p>Duplicate the file descriptor on plugin process server end of a stdio pipe.
This function is called once for each stdio pipe.  It is called after fork
and prior to the exec of the relay program. Only can only make async-safe
system calls. Errors are reported through the status pipe. </p></td>
          <td class="code"><div class="highlight"><pre>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">duplicate</span><span class="p">(</span><span class="kt">int</span> <span class="n">spipe</span><span class="p">,</span> <span class="kt">int</span> <span class="n">pipeno</span><span class="p">,</span> <span class="kt">int</span> <span class="n">end</span><span class="p">,</span> <span class="kt">int</span> <span class="n">fd</span><span class="p">)</span> <span class="p">{</span>
  <span class="kt">int</span> <span class="n">err</span><span class="p">;</span> 
  <span class="n">HANDLE_EINTR</span><span class="p">(</span><span class="n">dup2</span><span class="p">(</span><span class="n">process</span><span class="p">.</span><span class="n">pipes</span><span class="p">[</span><span class="n">pipeno</span><span class="p">][</span><span class="n">end</span><span class="p">],</span> <span class="n">fd</span><span class="p">),</span> <span class="n">err</span><span class="p">);</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">send_error</span><span class="p">(</span><span class="n">spipe</span><span class="p">,</span> <span class="n">START_CANNOT_DUP_STDIN_PIPE</span> <span class="o">+</span> <span class="n">pipeno</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></div></td>
        </tr>
      
        <tr>
          <td class="docs"><p>It is possible for the read above to be interrupted by a signal. It does not
seem possible for an interrupt to occur in the middle of an eight byte read
such that the read is partial.  The write operation on a pipe is atomic for
less than PIPE_BUF which is at least 512 bytes. It would seem that the read
is also atomic. It would seem that it would be atomic for the 4k page size
that appears everywhere in Linux. It doesn't say so, and in fact, the Linux
man pages state that, according to POSIX, read is allowed to return a number
of bytes read when EINTR can occurs.</p>

<p>These errors are given special error codes in the 900 range, indicating that
they are theoretical errors. I do not expect them to occur. If you get one of
these, let me know your platform.</p></td>
          <td class="code"><div class="highlight"><pre>
</pre></div></td>
        </tr>
      
        <tr>
          <td class="docs"><p>Encapsulates a test for an error condition that will never happen. </p></td>
          <td class="code"><div class="highlight"><pre>
<span class="cp">#define PARTIAL_READ(actual, expected, code, label) \</span>
<span class="cp">  FAIL(actual != expected, PARTIAL_ ## code, label)</span>
  </pre></div></td>
        </tr>
      
        <tr>
          <td class="docs"><p><code>launch</code> &mdash; Launch will fork and exec our relay program. The relay
program will close open file handles, reset signal handlers to the default
disposition, then launch the plugin server process.</p></td>
          <td class="code"><div class="highlight"><pre>
</pre></div></td>
        </tr>
      
        <tr>
          <td class="docs"><p>&#9824; </p></td>
          <td class="code"><div class="highlight"><pre>
<span class="k">static</span> <span class="kt">void</span> <span class="o">*</span><span class="nf">launch</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
  <span class="kt">int</span> <span class="n">status</span><span class="p">,</span> <span class="n">confirm</span><span class="p">,</span> <span class="n">spipe</span><span class="p">,</span> <span class="n">err</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">code</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>
</pre></div></td>
        </tr>
      
        <tr>
          <td class="docs"><p>Join the reaper thread. We do not need the result. </p></td>
          <td class="code"><div class="highlight"><pre>
  <span class="n">pthread_join</span><span class="p">(</span><span class="n">process</span><span class="p">.</span><span class="n">reaper</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
</pre></div></td>
        </tr>
      
        <tr>
          <td class="docs"><p>Create new pipes for stdio that reuse the file descriptor of the plugin
stub side of the previous stdio pipes. The pipe file descriptors stay the
same for the life cycle of the plugin, saving us some thread
sychnornization headaches. </p></td>
          <td class="code"><div class="highlight"><pre>
  <span class="n">recycle</span><span class="p">(</span><span class="n">PIPE_STDIN</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
  <span class="n">recycle</span><span class="p">(</span><span class="n">PIPE_STDOUT</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
  <span class="n">recycle</span><span class="p">(</span><span class="n">PIPE_STDERR</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
</pre></div></td>
        </tr>
      
        <tr>
          <td class="docs"><p>Create the remaning four pipes. The details of the pipes can be found in
the annotations above under the heading <strong>Pipes</strong>.</p></td>
          <td class="code"><div class="highlight"><pre>
  <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="n">PIPE_FORK</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">PIPE_CANARY</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">err</span> <span class="o">=</span> <span class="n">pipe</span><span class="p">(</span><span class="n">process</span><span class="p">.</span><span class="n">pipes</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
    <span class="n">FAIL</span><span class="p">(</span><span class="n">err</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">LAUNCH_CANNOT_CREATE_STDIN_PIPE</span> <span class="o">+</span> <span class="n">i</span><span class="p">,</span> <span class="n">fail</span><span class="p">);</span>
  <span class="p">}</span>
</pre></div></td>
        </tr>
      
        <tr>
          <td class="docs"><p>Except for STDIN, all the read ends of the pipes are close on exit. </p></td>
          <td class="code"><div class="highlight"><pre>
  <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="n">PIPE_STDOUT</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">PIPE_CANARY</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">fcntl</span><span class="p">(</span><span class="n">process</span><span class="p">.</span><span class="n">pipes</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="n">F_SETFD</span><span class="p">,</span> <span class="n">FD_CLOEXEC</span><span class="p">);</span>
  <span class="p">}</span>
</pre></div></td>
        </tr>
      
        <tr>
          <td class="docs"><p>The write ends of the STDIN and FORK pipes are close on exit. </p></td>
          <td class="code"><div class="highlight"><pre>
  <span class="n">fcntl</span><span class="p">(</span><span class="n">process</span><span class="p">.</span><span class="n">pipes</span><span class="p">[</span><span class="n">PIPE_STDIN</span><span class="p">][</span><span class="mi">1</span><span class="p">],</span> <span class="n">F_SETFD</span><span class="p">,</span> <span class="n">FD_CLOEXEC</span><span class="p">);</span>
  <span class="n">fcntl</span><span class="p">(</span><span class="n">process</span><span class="p">.</span><span class="n">pipes</span><span class="p">[</span><span class="n">PIPE_FORK</span><span class="p">][</span><span class="mi">1</span><span class="p">],</span> <span class="n">F_SETFD</span><span class="p">,</span> <span class="n">FD_CLOEXEC</span><span class="p">);</span>
</pre></div></td>
        </tr>
      
        <tr>
          <td class="docs"><p>Make the first argument to relay the string value of the status pipe. </p></td>
          <td class="code"><div class="highlight"><pre>
  <span class="n">spipe</span> <span class="o">=</span> <span class="n">process</span><span class="p">.</span><span class="n">pipes</span><span class="p">[</span><span class="n">PIPE_RELAY</span><span class="p">][</span><span class="mi">1</span><span class="p">];</span>
  <span class="n">process</span><span class="p">.</span><span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="mi">32</span><span class="p">);</span>
  <span class="n">FAIL</span><span class="p">(</span><span class="n">process</span><span class="p">.</span><span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">LAUNCH_CANNOT_MALLOC</span><span class="p">,</span> <span class="n">fail</span><span class="p">);</span>
  <span class="n">sprintf</span><span class="p">(</span><span class="n">process</span><span class="p">.</span><span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="s">&quot;%d&quot;</span><span class="p">,</span> <span class="n">spipe</span><span class="p">);</span>

  <span class="n">trace</span><span class="p">(</span><span class="s">&quot;launch&quot;</span><span class="p">,</span> <span class="s">&quot;fork&quot;</span><span class="p">);</span>
</pre></div></td>
        </tr>
      
        <tr>
          <td class="docs"><p>Let us fork.</p></td>
          <td class="code"><div class="highlight"><pre>
  <span class="n">process</span><span class="p">.</span><span class="n">pid</span> <span class="o">=</span> <span class="n">fork</span><span class="p">();</span>
</pre></div></td>
        </tr>
      
        <tr>
          <td class="docs"><p>A zero pid means that we are the child process. </p></td>
          <td class="code"><div class="highlight"><pre>
  <span class="k">if</span> <span class="p">(</span><span class="n">process</span><span class="p">.</span><span class="n">pid</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span></pre></div></td>
        </tr>
      
        <tr>
          <td class="docs"><p>We are in a race to fork. There is little we can do here because our host
application might be a multi-threaded application. Many system calls and
standard library calls are off limits. We can't malloc, for example. We
want to setup our pipes and launch our relay program, which will do the
reset of the cleanup. </p></td>
          <td class="code"><div class="highlight"><pre>
</pre></div></td>
        </tr>
      
        <tr>
          <td class="docs"><p>Create a pipe for stdout.  </p></td>
          <td class="code"><div class="highlight"><pre>
    <span class="n">duplicate</span><span class="p">(</span><span class="n">spipe</span><span class="p">,</span> <span class="n">PIPE_STDIN</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">STDIN_FILENO</span><span class="p">);</span>
    <span class="n">duplicate</span><span class="p">(</span><span class="n">spipe</span><span class="p">,</span> <span class="n">PIPE_STDOUT</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">STDOUT_FILENO</span><span class="p">);</span>
    <span class="c1">//duplicate(spipe, PIPE_STDERR, 0, 1, STDERR_FILENO);</span>
</pre></div></td>
        </tr>
      
        <tr>
          <td class="docs"><p>Duplicate the pulse pipe to the file descriptor specified at attendant
initialization.  dup2 will close the target file descriptor if it is
open. If the aribitrarily chosen fd assigned to the write end of the pipe
is by conicidence the canary file descriptor, dup2 does nothing. </p></td>
          <td class="code"><div class="highlight"><pre>
    <span class="n">HANDLE_EINTR</span><span class="p">(</span><span class="n">dup2</span><span class="p">(</span><span class="n">process</span><span class="p">.</span><span class="n">pipes</span><span class="p">[</span><span class="n">PIPE_CANARY</span><span class="p">][</span><span class="mi">1</span><span class="p">],</span> <span class="n">process</span><span class="p">.</span><span class="n">canary</span><span class="p">),</span> <span class="n">err</span><span class="p">);</span>

    <span class="n">execv</span><span class="p">(</span><span class="n">process</span><span class="p">.</span><span class="n">relay</span><span class="p">,</span> <span class="n">process</span><span class="p">.</span><span class="n">argv</span><span class="p">);</span>
</pre></div></td>
        </tr>
      
        <tr>
          <td class="docs"><p>If we are here, we did not execv. If we execv, the program is replace
with the relay program so this code is not executed. If we are here, we
report the error that occurred at execv. </p></td>
          <td class="code"><div class="highlight"><pre>
    <span class="n">send_error</span><span class="p">(</span><span class="n">spipe</span><span class="p">,</span> <span class="n">START_CANNOT_EXECV</span><span class="p">);</span>
</pre></div></td>
        </tr>
      
        <tr>
          <td class="docs"><p>We must call _exit and not exit. The exit call will trigger any atexit
handlers registered by the host application. The _exit call will not. </p></td>
          <td class="code"><div class="highlight"><pre>
</pre></div></td>
        </tr>
      
        <tr>
          <td class="docs"><p>Failure. </p></td>
          <td class="code"><div class="highlight"><pre>
    <span class="n">_exit</span><span class="p">(</span><span class="n">EXIT_FAILURE</span><span class="p">);</span></pre></div></td>
        </tr>
      
        <tr>
          <td class="docs"></td>
          <td class="code"><div class="highlight"><pre>
  <span class="p">}</span>
</pre></div></td>
        </tr>
      
        <tr>
          <td class="docs"><p>We are the parent. The child will never get here because of either the
execve or the _exit. </p></td>
          <td class="code"><div class="highlight"><pre>
</pre></div></td>
        </tr>
      
        <tr>
          <td class="docs"><p>We have failed to do so much as fork. Why does fork fail? Not enough
memory to copy the process, not enough memory in the kernel to allocate the
housekeeping, or there is resource limit on the number of processes. </p></td>
          <td class="code"><div class="highlight"><pre>
  <span class="n">FAIL</span><span class="p">(</span><span class="n">process</span><span class="p">.</span><span class="n">pid</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">LAUNCH_CANNOT_FORK</span><span class="p">,</span> <span class="n">fail</span><span class="p">);</span>
</pre></div></td>
        </tr>
      
        <tr>
          <td class="docs"><p>Close the child end of all of the pipes we've just created. We do not close
the reaper pipe, of course, because it lasts for the life time of the
plugin attendant. </p></td>
          <td class="code"><div class="highlight"><pre>
  <span class="n">close_pipe</span><span class="p">(</span><span class="n">PIPE_STDIN</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
  <span class="n">close_pipe</span><span class="p">(</span><span class="n">PIPE_STDOUT</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
  <span class="n">close_pipe</span><span class="p">(</span><span class="n">PIPE_STDERR</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
  <span class="n">close_pipe</span><span class="p">(</span><span class="n">PIPE_FORK</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
  <span class="n">close_pipe</span><span class="p">(</span><span class="n">PIPE_RELAY</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
  <span class="n">close_pipe</span><span class="p">(</span><span class="n">PIPE_CANARY</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
</pre></div></td>
        </tr>
      
        <tr>
          <td class="docs"><p>Wait for the fork pipe to close. It will be a read that returns zero bytes.
We're only interested in a successful return. The buffer will be empty. </p></td>
          <td class="code"><div class="highlight"><pre>
  <span class="n">HANDLE_EINTR</span><span class="p">(</span><span class="n">read</span><span class="p">(</span><span class="n">process</span><span class="p">.</span><span class="n">pipes</span><span class="p">[</span><span class="n">PIPE_FORK</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="o">&amp;</span><span class="n">confirm</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">confirm</span><span class="p">)),</span> <span class="n">err</span><span class="p">);</span>
  </pre></div></td>
        </tr>
      
        <tr>
          <td class="docs"><p>Close the file descriptor of the plugin stub end of the status pipe. </p></td>
          <td class="code"><div class="highlight"><pre>
  <span class="n">close_pipe</span><span class="p">(</span><span class="n">PIPE_FORK</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
</pre></div></td>
        </tr>
      
        <tr>
          <td class="docs"><p>Many of the error checks below are assertions, not exception handlers.</p>

<p>What follows are a lot of error conditions that can only occur if someone,
probably me, breaks the plugin attendant itself. We're testing that the
operating system does indeed pass to a program the arguments we ask it to
pass. We're testing that when we write to a pipe, that the same data will
be read from the pipe.</p>

<p>We're confirming the values that we've fed to the relay program as
arguments, that the relay program is echoing back to us through its pipes.
This is were checking every error code becomes academic.</p>

<p>This is why test coverage, especially at this level, can be a rabbit hole.
To get 100% coverage, we'd have to create a different version of the relay
program that triggered errors that are theoretical. It would have to send
only three bytes of an integer, to simulate a partial pipe read. A pipe
write of under 512 bytes is atomic, so the only way to trigger this error
is to create a bogus relay program, or else hack the operating system.</p></td>
          <td class="code"><div class="highlight"><pre>
</pre></div></td>
        </tr>
      
        <tr>
          <td class="docs"><p>The relay will write the status pipe file descriptor to stdandard out. </p></td>
          <td class="code"><div class="highlight"><pre>
  <span class="n">HANDLE_EINTR</span><span class="p">(</span><span class="n">read</span><span class="p">(</span><span class="n">process</span><span class="p">.</span><span class="n">pipes</span><span class="p">[</span><span class="n">PIPE_STDOUT</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="o">&amp;</span><span class="n">confirm</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">confirm</span><span class="p">)),</span> <span class="n">err</span><span class="p">);</span>
</pre></div></td>
        </tr>
      
        <tr>
          <td class="docs"><p>If zero, the standard I/O pipe hung up, it means the relay did not execute
or exited immediately. </p></td>
          <td class="code"><div class="highlight"><pre>
  <span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span></pre></div></td>
        </tr>
      
        <tr>
          <td class="docs"><p>Read the error code. </p></td>
          <td class="code"><div class="highlight"><pre>
    <span class="n">HANDLE_EINTR</span><span class="p">(</span><span class="n">read</span><span class="p">(</span><span class="n">process</span><span class="p">.</span><span class="n">pipes</span><span class="p">[</span><span class="n">PIPE_RELAY</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="n">code</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">code</span><span class="p">)),</span> <span class="n">err</span><span class="p">);</span>
</pre></div></td>
        </tr>
      
        <tr>
          <td class="docs"><p>Zero bytes returned means the relay program exited immediately because we
fed it a malformed status pipe file descriptor.  It won't write an error
because it doesn't have a status pipe. You can see above that we format
the file descriptor correctly, so consider this an assertion. </p></td>
          <td class="code"><div class="highlight"><pre>
    <span class="n">FAIL</span><span class="p">(</span><span class="n">err</span> <span class="o">==</span> <span class="mi">0</span><span class="p">,</span> <span class="n">LAUNCH_IMMEDIATE_RELAY_EXIT</span><span class="p">,</span> <span class="n">fail</span><span class="p">);</span> 
  </pre></div></td>
        </tr>
      
        <tr>
          <td class="docs"><p>Theoretical error. Read is probably atomic for under 4k. </p></td>
          <td class="code"><div class="highlight"><pre>
    <span class="n">PARTIAL_READ</span><span class="p">(</span><span class="n">err</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">code</span><span class="p">),</span> <span class="n">FORK_ERROR_CODE</span><span class="p">,</span> <span class="n">fail</span><span class="p">);</span>
</pre></div></td>
        </tr>
      
        <tr>
          <td class="docs"><p>Set the plugin attendant error code and system error number. </p></td>
          <td class="code"><div class="highlight"><pre>
    <span class="n">process</span><span class="p">.</span><span class="n">last_error</span> <span class="o">=</span> <span class="n">code</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
    <span class="n">process</span><span class="p">.</span><span class="n">last_errno</span> <span class="o">=</span> <span class="n">code</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
</pre></div></td>
        </tr>
      
        <tr>
          <td class="docs"><p>Abend. </p></td>
          <td class="code"><div class="highlight"><pre>
    <span class="k">goto</span> <span class="n">fail</span><span class="p">;</span></pre></div></td>
        </tr>
      
        <tr>
          <td class="docs"><p>&mdash; </p></td>
          <td class="code"><div class="highlight"><pre>
  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span></pre></div></td>
        </tr>
      
        <tr>
          <td class="docs"><p>Theoretical error. Read is probably atomic for under 4k. </p></td>
          <td class="code"><div class="highlight"><pre>
    <span class="n">PARTIAL_READ</span><span class="p">(</span><span class="n">err</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">confirm</span><span class="p">),</span> <span class="n">STDOUT_STATUS_PIPE_NUMBER</span><span class="p">,</span> <span class="n">fail</span><span class="p">);</span>
</pre></div></td>
        </tr>
      
        <tr>
          <td class="docs"><p>Assert that we passed the correct file descriptor through stdout. </p></td>
          <td class="code"><div class="highlight"><pre>
    <span class="n">FAIL</span><span class="p">(</span><span class="n">confirm</span> <span class="o">!=</span> <span class="n">spipe</span><span class="p">,</span> <span class="n">LAUNCH_RELAY_PIPE_STDOUT_FAILED</span><span class="p">,</span> <span class="n">fail</span><span class="p">);</span> 
</pre></div></td>
        </tr>
      
        <tr>
          <td class="docs"><p>Read the status pipe file descriptor number from the status pipe itself. </p></td>
          <td class="code"><div class="highlight"><pre>
    <span class="n">HANDLE_EINTR</span><span class="p">(</span><span class="n">read</span><span class="p">(</span><span class="n">process</span><span class="p">.</span><span class="n">pipes</span><span class="p">[</span><span class="n">PIPE_RELAY</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="o">&amp;</span><span class="n">confirm</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">confirm</span><span class="p">)),</span> <span class="n">err</span><span class="p">);</span>
</pre></div></td>
        </tr>
      
        <tr>
          <td class="docs"><p>Assert that the relay pipe is still open. </p></td>
          <td class="code"><div class="highlight"><pre>
    <span class="n">FAIL</span><span class="p">(</span><span class="n">err</span> <span class="o">==</span> <span class="mi">0</span><span class="p">,</span> <span class="n">LAUNCH_RELAY_PIPE_HUNG_UP</span><span class="p">,</span> <span class="n">fail</span><span class="p">);</span> 
</pre></div></td>
        </tr>
      
        <tr>
          <td class="docs"><p>Theoretical error. Read is probably atomic for under 4k. </p></td>
          <td class="code"><div class="highlight"><pre>
    <span class="n">PARTIAL_READ</span><span class="p">(</span><span class="n">err</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">confirm</span><span class="p">),</span> <span class="n">STATUS_PIPE_NUMBER</span><span class="p">,</span> <span class="n">fail</span><span class="p">);</span>
</pre></div></td>
        </tr>
      
        <tr>
          <td class="docs"><p>Assert that we passed the correct file descriptor through the status pipe. </p></td>
          <td class="code"><div class="highlight"><pre>
    <span class="n">FAIL</span><span class="p">(</span><span class="n">confirm</span> <span class="o">!=</span> <span class="n">spipe</span><span class="p">,</span> <span class="n">LAUNCH_RELAY_PIPE_STDOUT_FAILED</span><span class="p">,</span> <span class="n">fail</span><span class="p">);</span> </pre></div></td>
        </tr>
      
        <tr>
          <td class="docs"></td>
          <td class="code"><div class="highlight"><pre>
  <span class="p">}</span>
</pre></div></td>
        </tr>
      
        <tr>
          <td class="docs"><p>Now know that our status pipe is setup correctly, read an error if any. </p></td>
          <td class="code"><div class="highlight"><pre>
  <span class="n">HANDLE_EINTR</span><span class="p">(</span><span class="n">read</span><span class="p">(</span><span class="n">process</span><span class="p">.</span><span class="n">pipes</span><span class="p">[</span><span class="n">PIPE_RELAY</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="n">code</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">code</span><span class="p">)),</span> <span class="n">err</span><span class="p">);</span>
</pre></div></td>
        </tr>
      
        <tr>
          <td class="docs"><p>Zero means we hung, up. which is wonderful. Our plugin server process is up
and running. Otherwise, the relay program encoutered an error. </p></td>
          <td class="code"><div class="highlight"><pre>
  <span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span></pre></div></td>
        </tr>
      
        <tr>
          <td class="docs"><p>Theoretical error. Read is probably atomic for under 4k. </p></td>
          <td class="code"><div class="highlight"><pre>
    <span class="n">PARTIAL_READ</span><span class="p">(</span><span class="n">err</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">code</span><span class="p">),</span> <span class="n">EXEC_ERROR_CODE</span><span class="p">,</span> <span class="n">fail</span><span class="p">);</span>
</pre></div></td>
        </tr>
      
        <tr>
          <td class="docs"><p>Set the plugin attendant error code and system error number. </p></td>
          <td class="code"><div class="highlight"><pre>
    <span class="n">process</span><span class="p">.</span><span class="n">last_error</span> <span class="o">=</span> <span class="n">code</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
    <span class="n">process</span><span class="p">.</span><span class="n">last_errno</span> <span class="o">=</span> <span class="n">code</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
</pre></div></td>
        </tr>
      
        <tr>
          <td class="docs"><p>Abend. </p></td>
          <td class="code"><div class="highlight"><pre>
    <span class="k">goto</span> <span class="n">fail</span><span class="p">;</span>
  <span class="p">}</span>
</pre></div></td>
        </tr>
      
        <tr>
          <td class="docs"><p>Our server process is now up and running correctly. Time to launch the
reaper thread. This reaper thread monitor the plugin server process for
termination. </p></td>
          <td class="code"><div class="highlight"><pre>
  <span class="n">pthread_create</span><span class="p">(</span><span class="o">&amp;</span><span class="n">process</span><span class="p">.</span><span class="n">reaper</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">reap</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
</pre></div></td>
        </tr>
      
        <tr>
          <td class="docs"><p>Don't need these anymore. </p></td>
          <td class="code"><div class="highlight"><pre>
  <span class="n">free_argv</span><span class="p">();</span>

  <span class="n">trace</span><span class="p">(</span><span class="s">&quot;launch&quot;</span><span class="p">,</span> <span class="s">&quot;success&quot;</span><span class="p">);</span>
</pre></div></td>
        </tr>
      
        <tr>
          <td class="docs"></td>
          <td class="code"><div class="highlight"><pre>
  <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

<span class="nl">fail:</span>

  <span class="n">trace</span><span class="p">(</span><span class="s">&quot;launch&quot;</span><span class="p">,</span> <span class="s">&quot;failure&quot;</span><span class="p">);</span>

  <span class="k">if</span> <span class="p">(</span><span class="n">process</span><span class="p">.</span><span class="n">pid</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span></pre></div></td>
        </tr>
      
        <tr>
          <td class="docs"><p>There is no logic in the relay that doesn't exit immediately. If it is
hung and a <code>SIGKILL</code> is necessary, then plugin attendant is broken. </p></td>
          <td class="code"><div class="highlight"><pre>
    <span class="n">kill</span><span class="p">(</span><span class="n">process</span><span class="p">.</span><span class="n">pid</span><span class="p">,</span> <span class="n">SIGKILL</span><span class="p">);</span>
</pre></div></td>
        </tr>
      
        <tr>
          <td class="docs"><p>Reap the process. If the host application is set to ignore <code>SIGCHLD</code> then
we skip this step. </p></td>
          <td class="code"><div class="highlight"><pre>
    <span class="k">if</span> <span class="p">(</span><span class="n">process</span><span class="p">.</span><span class="n">waitable</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">HANDLE_EINTR</span><span class="p">(</span><span class="n">waitpid</span><span class="p">(</span><span class="n">process</span><span class="p">.</span><span class="n">pid</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">status</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="n">err</span><span class="p">);</span>
    <span class="p">}</span>
  <span class="p">}</span>
</pre></div></td>
        </tr>
      
        <tr>
          <td class="docs"><p>Close the pipes we created. </p></td>
          <td class="code"><div class="highlight"><pre>
  <span class="n">close_pipes</span><span class="p">();</span>
</pre></div></td>
        </tr>
      
        <tr>
          <td class="docs"><p>Release the arguments. </p></td>
          <td class="code"><div class="highlight"><pre>
  <span class="n">free_argv</span><span class="p">();</span>
</pre></div></td>
        </tr>
      
        <tr>
          <td class="docs"><p>We go into our abend procedure. </p></td>
          <td class="code"><div class="highlight"><pre>
  <span class="n">signal_termination</span><span class="p">();</span>

  <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>
</pre></div></td>
        </tr>
      
        <tr>
          <td class="docs"><h3>Reaper</h3></td>
          <td class="code"><div class="highlight"><pre>
</pre></div></td>
        </tr>
      
        <tr>
          <td class="docs"><p>The reaper thread waits for the plugin server process to exit by polling to
the canary pipe for hang up. We do this because we cannot count on <code>waitpid</code>.</p>

<p>There are two ways in which the exit status from the server process may be
intercepted. First, we might not be able to use <code>waitpid</code> at all, because the
host program set <code>SIGCHLD</code> to <code>SIG_IGN</code>. Second, if <code>SIGCHLD</code> is waitable,
the host application might be doing a blanket wait, and it might reap the
child process, obtaining the pid, leaving us with an <code>ECHILD</code> error. Thus, we
don't bother saving the exit code.</p></td>
          <td class="code"><div class="highlight"><pre>
</pre></div></td>
        </tr>
      
        <tr>
          <td class="docs"><p>&#9824; </p></td>
          <td class="code"><div class="highlight"><pre>
<span class="k">static</span> <span class="kt">void</span><span class="o">*</span> <span class="nf">reap</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
  <span class="k">static</span> <span class="kt">int</span> <span class="n">REAPER</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">CANARY</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="n">input</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">instance</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
    <span class="n">sig</span> <span class="o">=</span> <span class="n">SIGTERM</span><span class="p">,</span> <span class="n">timeout</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">hangup</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">shutdown</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">status</span><span class="p">,</span> <span class="n">err</span><span class="p">;</span>
  <span class="k">struct</span> <span class="n">pollfd</span> <span class="n">channels</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>
</pre></div></td>
        </tr>
      
        <tr>
          <td class="docs"><p>Join the reaper launcher. We do not need the result. </p></td>
          <td class="code"><div class="highlight"><pre>
  <span class="n">pthread_join</span><span class="p">(</span><span class="n">process</span><span class="p">.</span><span class="n">launcher</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
</pre></div></td>
        </tr>
      
        <tr>
          <td class="docs"><p>Tell the library stub functions that we are running. </p></td>
          <td class="code"><div class="highlight"><pre>
  <span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="n">pthread_mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">process</span><span class="p">.</span><span class="n">mutex</span><span class="p">);</span>
  <span class="n">process</span><span class="p">.</span><span class="n">running</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
  <span class="n">process</span><span class="p">.</span><span class="n">restarting</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="n">pthread_cond_signal</span><span class="p">(</span><span class="o">&amp;</span><span class="n">process</span><span class="p">.</span><span class="n">cond</span><span class="p">.</span><span class="n">running</span><span class="p">);</span>
  <span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="n">pthread_mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">process</span><span class="p">.</span><span class="n">mutex</span><span class="p">);</span>
</pre></div></td>
        </tr>
      
        <tr>
          <td class="docs"><p>Loop until the plugin server process exits. </p></td>
          <td class="code"><div class="highlight"><pre>
  <span class="k">do</span> <span class="p">{</span></pre></div></td>
        </tr>
      
        <tr>
          <td class="docs"><p>The other end of the canary pipe is held by the library server process.
It is not used for communication, only to detect the termination of the
library server process. When it closes, we know we are terminated.</p>

<p>The instance pipe is a way for the plugin stub to tell the reaper thread
that the library server process has become unresponsive. We can be awoken
by the instance pipe, telling us that the library stub functions have
detected a dead server process. When we get an instance number, we will
kill the running process if the instance number is greater than the
current process instance number.</p>

<p>If instance number is -1, a shutdown is pending and we continue to wait
on the canary pipe. When it closes, we know not to restart the server. </p></td>
          <td class="code"><div class="highlight"><pre>
</pre></div></td>
        </tr>
      
        <tr>
          <td class="docs"><p>Poll the instance and canary pipes. </p></td>
          <td class="code"><div class="highlight"><pre>
    <span class="n">channels</span><span class="p">[</span><span class="n">REAPER</span><span class="p">].</span><span class="n">events</span> <span class="o">=</span> <span class="n">POLLIN</span><span class="p">;</span>
    <span class="n">channels</span><span class="p">[</span><span class="n">REAPER</span><span class="p">].</span><span class="n">revents</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</pre></div></td>
        </tr>
      
        <tr>
          <td class="docs"><p>Might be visiting this twice, due to SIGTERM, then getting a new instance
number. Ah, but the instance number can't be greater than the current
number, because it only gets incremented in the launcher thread, so this
is okay. Unless we get a scram, but that is fine too.</p></td>
          <td class="code"><div class="highlight"><pre>
</pre></div></td>
        </tr>
      
        <tr>
          <td class="docs"></td>
          <td class="code"><div class="highlight"><pre>
    <span class="n">channels</span><span class="p">[</span><span class="n">CANARY</span><span class="p">].</span><span class="n">events</span> <span class="o">=</span> <span class="n">POLLHUP</span><span class="p">;</span>
    <span class="n">channels</span><span class="p">[</span><span class="n">CANARY</span><span class="p">].</span><span class="n">revents</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

    <span class="n">channels</span><span class="p">[</span><span class="n">REAPER</span><span class="p">].</span><span class="n">fd</span> <span class="o">=</span> <span class="n">process</span><span class="p">.</span><span class="n">pipes</span><span class="p">[</span><span class="n">PIPE_REAPER</span><span class="p">][</span><span class="mi">0</span><span class="p">];</span>
    <span class="n">channels</span><span class="p">[</span><span class="n">CANARY</span><span class="p">].</span><span class="n">fd</span> <span class="o">=</span> <span class="n">process</span><span class="p">.</span><span class="n">pipes</span><span class="p">[</span><span class="n">PIPE_CANARY</span><span class="p">][</span><span class="mi">0</span><span class="p">];</span>

    <span class="n">trace</span><span class="p">(</span><span class="s">&quot;reap&quot;</span><span class="p">,</span> <span class="s">&quot;poll&quot;</span><span class="p">);</span>

    <span class="n">HANDLE_EINTR</span><span class="p">(</span><span class="n">poll</span><span class="p">(</span><span class="n">channels</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">timeout</span><span class="p">),</span> <span class="n">err</span><span class="p">);</span>
</pre></div></td>
        </tr>
      
        <tr>
          <td class="docs"><p>Note that, errors here make the situation hopeless. If we encouter errors
with the process monitoring pipes, we go to the shutdown state. </p></td>
          <td class="code"><div class="highlight"><pre>
</pre></div></td>
        </tr>
      
        <tr>
          <td class="docs"><p>Did the monitored process terminate? </p></td>
          <td class="code"><div class="highlight"><pre>
    <span class="k">if</span> <span class="p">(</span><span class="n">channels</span><span class="p">[</span><span class="n">CANARY</span><span class="p">].</span><span class="n">revents</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">trace</span><span class="p">(</span><span class="s">&quot;reap&quot;</span><span class="p">,</span> <span class="s">&quot;hangup&quot;</span><span class="p">);</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">channels</span><span class="p">[</span><span class="n">CANARY</span><span class="p">].</span><span class="n">revents</span> <span class="o">==</span> <span class="n">POLLHUP</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">hangup</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
      <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="n">set_error</span><span class="p">(</span><span class="n">REAPER_UNEXPECTED_CANARY_PIPE_EVENT</span><span class="p">);</span>
      <span class="p">}</span>
    <span class="p">}</span>
</pre></div></td>
        </tr>
      
        <tr>
          <td class="docs"><p>Did we get an instance number from the plugin stub? </p></td>
          <td class="code"><div class="highlight"><pre>
    <span class="k">if</span> <span class="p">(</span><span class="n">channels</span><span class="p">[</span><span class="n">REAPER</span><span class="p">].</span><span class="n">revents</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">channels</span><span class="p">[</span><span class="n">REAPER</span><span class="p">].</span><span class="n">revents</span> <span class="o">==</span> <span class="n">POLLIN</span><span class="p">)</span> <span class="p">{</span></pre></div></td>
        </tr>
      
        <tr>
          <td class="docs"><p>Read the message from the user. </p></td>
          <td class="code"><div class="highlight"><pre>
        <span class="n">HANDLE_EINTR</span><span class="p">(</span><span class="n">read</span><span class="p">(</span><span class="n">process</span><span class="p">.</span><span class="n">pipes</span><span class="p">[</span><span class="n">PIPE_REAPER</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="n">input</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">input</span><span class="p">)),</span> <span class="n">err</span><span class="p">);</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">!=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">input</span><span class="p">))</span> <span class="p">{</span></pre></div></td>
        </tr>
      
        <tr>
          <td class="docs"><p>Any error reading the instance pipe means we shutdown for good. </p></td>
          <td class="code"><div class="highlight"><pre>
          <span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">set_error</span><span class="p">(</span><span class="n">REAPER_CANNOT_READ_REAPER_PIPE</span><span class="p">);</span>
          <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="n">set_error</span><span class="p">(</span><span class="n">REAPER_TRUNCATED_READ_REAPER_PIPE</span><span class="p">);</span>
          <span class="p">}</span>

        <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">input</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
          <span class="n">trace</span><span class="p">(</span><span class="s">&quot;reap&quot;</span><span class="p">,</span> <span class="s">&quot;shutdown&quot;</span><span class="p">);</span>
          <span class="n">shutdown</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
        <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">input</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">instance</span><span class="p">)</span> <span class="p">{</span></pre></div></td>
        </tr>
      
        <tr>
          <td class="docs"><p>We will restart if we get an instance number higher than the static
instance number. If we get a <code>-1</code> we shutdown. </p></td>
          <td class="code"><div class="highlight"><pre>
          <span class="n">trace</span><span class="p">(</span><span class="s">&quot;reap&quot;</span><span class="p">,</span> <span class="s">&quot;instance&quot;</span><span class="p">);</span>
          <span class="n">instance</span> <span class="o">=</span> <span class="n">input</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span></pre></div></td>
        </tr>
      
        <tr>
          <td class="docs"></td>
          <td class="code"><div class="highlight"><pre>
        <span class="p">}</span>
      <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="n">set_error</span><span class="p">(</span><span class="n">REAPER_UNEXPECTED_REAPER_PIPE_EVENT</span><span class="p">);</span>
      <span class="p">}</span>
    <span class="p">}</span>
</pre></div></td>
        </tr>
      
        <tr>
          <td class="docs"><p>If we're getting unexpected errors from reading the pipes, we've entered
an unstable state. We don't want the plugin attendant itself to hang, and
it can't seem to rely on useful behavior from pipes, so we nuke it from
orbit. It's the only way to be sure. </p></td>
          <td class="code"><div class="highlight"><pre>
    <span class="k">if</span> <span class="p">(</span><span class="n">process</span><span class="p">.</span><span class="n">last_error</span><span class="p">)</span> <span class="p">{</span></pre></div></td>
        </tr>
      
        <tr>
          <td class="docs"><p>Trigger a shutdown. </p></td>
          <td class="code"><div class="highlight"><pre>
      <span class="n">shutdown</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span></pre></div></td>
        </tr>
      
        <tr>
          <td class="docs"><p>Leave the reaper pipe polling loop. </p></td>
          <td class="code"><div class="highlight"><pre>
      <span class="n">hangup</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span></pre></div></td>
        </tr>
      
        <tr>
          <td class="docs"><p>Nuke it from orbit. It's the only way to be sure. </p></td>
          <td class="code"><div class="highlight"><pre>
      <span class="n">kill</span><span class="p">(</span><span class="n">process</span><span class="p">.</span><span class="n">pid</span><span class="p">,</span> <span class="n">SIGKILL</span><span class="p">);</span>
    <span class="p">}</span>
</pre></div></td>
        </tr>
      
        <tr>
          <td class="docs"><p>Note if we got a shutdown from the instance pipe. The next time we detect
that the plugin server process has exited, we will not try to restart it.</p>

<p>We trigger both shutdown and running thread conditions. The shutdown
function waits to know that the process has shutdown. Other functions
wait for the process to run again, and this will wake them so then can
see that the process will never run again. </p></td>
          <td class="code"><div class="highlight"><pre>
    <span class="k">if</span> <span class="p">(</span><span class="n">shutdown</span><span class="p">)</span> <span class="p">{</span>
      <span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="n">pthread_mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">process</span><span class="p">.</span><span class="n">mutex</span><span class="p">);</span>
      <span class="n">process</span><span class="p">.</span><span class="n">shutdown</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
      <span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="n">pthread_cond_signal</span><span class="p">(</span><span class="o">&amp;</span><span class="n">process</span><span class="p">.</span><span class="n">cond</span><span class="p">.</span><span class="n">running</span><span class="p">);</span>
      <span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="n">pthread_cond_signal</span><span class="p">(</span><span class="o">&amp;</span><span class="n">process</span><span class="p">.</span><span class="n">cond</span><span class="p">.</span><span class="n">shutdown</span><span class="p">);</span>
      <span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="n">pthread_mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">process</span><span class="p">.</span><span class="n">mutex</span><span class="p">);</span>
      <span class="n">shutdown</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="p">}</span>
</pre></div></td>
        </tr>
      
        <tr>
          <td class="docs"><p>If we are restarting but have not received a hang up, kill. First with a
<code>SIGTERM</code> then with a <code>SIGKILL</code>. We give the process a half second to
shutdown after a <code>SIGTERM</code>, but wait indefinately after the <code>SIGKILL</code>. </p></td>
          <td class="code"><div class="highlight"><pre>
    <span class="k">if</span> <span class="p">(</span><span class="n">instance</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">hangup</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">kill</span><span class="p">(</span><span class="n">process</span><span class="p">.</span><span class="n">pid</span><span class="p">,</span> <span class="n">sig</span><span class="p">);</span>
      <span class="n">timeout</span> <span class="o">=</span> <span class="n">sig</span> <span class="o">==</span> <span class="n">SIGTERM</span> <span class="o">?</span> <span class="n">input</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">:</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
      <span class="n">sig</span> <span class="o">=</span> <span class="n">SIGKILL</span><span class="p">;</span>
      <span class="k">continue</span><span class="p">;</span>
    <span class="p">}</span></pre></div></td>
        </tr>
      
        <tr>
          <td class="docs"><p>Repeat until the plugin server process exits. </p></td>
          <td class="code"><div class="highlight"><pre>
  <span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">hangup</span><span class="p">);</span>

  <span class="n">trace</span><span class="p">(</span><span class="s">&quot;reap&quot;</span><span class="p">,</span> <span class="s">&quot;hungup&quot;</span><span class="p">);</span>
</pre></div></td>
        </tr>
      
        <tr>
          <td class="docs"><p>TODO Log restart reason? No. We have no good reason. Or, hmm... Sure, why
not? </p></td>
          <td class="code"><div class="highlight"><pre>
</pre></div></td>
        </tr>
      
        <tr>
          <td class="docs"><p>The waitable flag was determined at initialization. We never check again.
A host application that changes <code>SIGCHLD</code> disposition every now and again
is far to shabby to support. </p></td>
          <td class="code"><div class="highlight"><pre>
</pre></div></td>
        </tr>
      
        <tr>
          <td class="docs"><p>If we are waitable use <code>waitpid</code>. </p></td>
          <td class="code"><div class="highlight"><pre>
  <span class="k">if</span> <span class="p">(</span><span class="n">process</span><span class="p">.</span><span class="n">waitable</span><span class="p">)</span> <span class="p">{</span></pre></div></td>
        </tr>
      
        <tr>
          <td class="docs"><p>Our host application might also be waiting on the pid, by using a global
wait to wait until any child terminates. That means that the host
application might be the one to reap the child. If that is the case, then
we got an error and errno is ECHILD, meaning that the child does not
exist. The non-existance of the child is death enough for our purposes.</p>

<p>So, ECHILD is not really an error, we are retrying on EINTR, so that
leaves EINVAL, which we're not going to trigger. Let's move on.  </p></td>
          <td class="code"><div class="highlight"><pre>
</pre></div></td>
        </tr>
      
        <tr>
          <td class="docs"><p>We wait for the child process to exit, blocking until it exits. </p></td>
          <td class="code"><div class="highlight"><pre>
    <span class="n">HANDLE_EINTR</span><span class="p">(</span><span class="n">waitpid</span><span class="p">(</span><span class="n">process</span><span class="p">.</span><span class="n">pid</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">status</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="n">err</span><span class="p">);</span></pre></div></td>
        </tr>
      
        <tr>
          <td class="docs"><p>&mdash; </p></td>
          <td class="code"><div class="highlight"><pre>
  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span></pre></div></td>
        </tr>
      
        <tr>
          <td class="docs"><p>There is a theoretical race condition, where the process id may be
reused. When a pid is released by the operating system, the operating
system can reuse it. It is released when the child process is reaped,
when wait is called, or child signals are ignored or simply not generated
due do SIGCHLD beign set to SIG_IGN, as is the case here.</p>

<p>We have a race condition where the the library server child process
exits, the host program spawns a new child, and that new child is
assigned the pid of the dead, reaped library server child process. If
this occurs during our timed wait, then when we wake up, kill will tell
us that, yes, there is a child with the pid you requested, and it is
alive and kicking.</p>

<p>On the target operating systems targeted at the time of writing, pids
appear to get assigned in sequential order, wrapping when the pid values
approach the maxiumum value of the pid type. Which means that we're in a
race with 60,000 process starts and exits. Likely we will win.</p>

<p>Then, the pid, when it does comes around again, needs to be assigned to a
child process spawned by our the owner of our host application, because
kill can only send signals to processes owned by the same user. (Unless
we're running as root, but that is madness.)</p>

<p>There are operating systems that, for security reasons, <a href="http://www.faqs.org/faqs/aix-faq/part2/section-20.html">assign pids
randomly</a>. This
may make it more likely that our pid will get reassigned to a new
process, baring any logic in the randomizer that holds off on reusing a
pid for a few ticks. Again, it has to be the same user as the host
application that draws the pid for it to be problem.</p>

<p>It is one of those things were the standard promises only so much. The
standards says only that the pid is reserved until the child is reaped.</p>

<p>Thus, there is a theoretical race condition here. In fact, the same race
condition applies to the <code>waitpid</code> branch if the host application reaps
the child before us. Oh, the peril.</p></td>
          <td class="code"><div class="highlight"><pre>
</pre></div></td>
        </tr>
      
        <tr>
          <td class="docs"><p>Loop while the pid is still valid. </p></td>
          <td class="code"><div class="highlight"><pre>
    <span class="k">while</span> <span class="p">(</span><span class="n">getpgid</span><span class="p">(</span><span class="n">process</span><span class="p">.</span><span class="n">pid</span><span class="p">)</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span></pre></div></td>
        </tr>
      
        <tr>
          <td class="docs"><p>Wait for a quarter of a second and check the pid again. We use a
condition that is used only for this test. We want the timeout, not the
signaling. The wait will cause us to release the mutex. </p></td>
          <td class="code"><div class="highlight"><pre>
      <span class="n">pthread_mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">process</span><span class="p">.</span><span class="n">mutex</span><span class="p">);</span>
      <span class="n">pthread_cond_waitforabit</span><span class="p">(</span><span class="o">&amp;</span><span class="n">process</span><span class="p">.</span><span class="n">cond</span><span class="p">.</span><span class="n">getgpid</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">process</span><span class="p">.</span><span class="n">mutex</span><span class="p">,</span> <span class="mi">250</span><span class="p">);</span>
      <span class="n">pthread_mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">process</span><span class="p">.</span><span class="n">mutex</span><span class="p">);</span></pre></div></td>
        </tr>
      
        <tr>
          <td class="docs"></td>
          <td class="code"><div class="highlight"><pre>
    <span class="p">}</span>
  <span class="p">}</span>
</pre></div></td>
        </tr>
      
        <tr>
          <td class="docs"><p>Cleanup. </p></td>
          <td class="code"><div class="highlight"><pre>
  <span class="n">signal_termination</span><span class="p">();</span>
</pre></div></td>
        </tr>
      
        <tr>
          <td class="docs"><p>The thread return value is unused. </p></td>
          <td class="code"><div class="highlight"><pre>
  <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
</pre></div></td>
        </tr>
      
        <tr>
          <td class="docs"><p>&mdash; </p></td>
          <td class="code"><div class="highlight"><pre>
<span class="p">}</span>
</pre></div></td>
        </tr>
      
        <tr>
          <td class="docs"><p>Cleanup when we fail to start the launcher thread, fail to launch the plugin
server program, or detect that the plugin server process has exited. </p></td>
          <td class="code"><div class="highlight"><pre>
</pre></div></td>
        </tr>
      
        <tr>
          <td class="docs"></td>
          <td class="code"><div class="highlight"><pre>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">signal_termination</span><span class="p">()</span> <span class="p">{</span>
  <span class="kt">int</span> <span class="n">instance</span><span class="p">;</span>
</pre></div></td>
        </tr>
      
        <tr>
          <td class="docs"><p>Don't need the process identifier anymore. </p></td>
          <td class="code"><div class="highlight"><pre>
  <span class="n">process</span><span class="p">.</span><span class="n">pid</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</pre></div></td>
        </tr>
      
        <tr>
          <td class="docs"><p>Dip into our mutex. </p></td>
          <td class="code"><div class="highlight"><pre>
  <span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="n">pthread_mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">process</span><span class="p">.</span><span class="n">mutex</span><span class="p">);</span>
</pre></div></td>
        </tr>
      
        <tr>
          <td class="docs"><p>Take note of whether we sould invoke the abend handler. Reset for an
orderly restart. Do not reset shutdown here, only stopped. </p></td>
          <td class="code"><div class="highlight"><pre>
  <span class="n">process</span><span class="p">.</span><span class="n">restarting</span> <span class="o">=</span> <span class="o">!</span><span class="n">process</span><span class="p">.</span><span class="n">shutdown</span><span class="p">;</span>
  <span class="n">process</span><span class="p">.</span><span class="n">running</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="n">instance</span> <span class="o">=</span> <span class="n">process</span><span class="p">.</span><span class="n">instance</span><span class="p">;</span>
</pre></div></td>
        </tr>
      
        <tr>
          <td class="docs"><p>Signal any thread waiting on a running state change. </p></td>
          <td class="code"><div class="highlight"><pre>
  <span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="n">pthread_cond_signal</span><span class="p">(</span><span class="o">&amp;</span><span class="n">process</span><span class="p">.</span><span class="n">cond</span><span class="p">.</span><span class="n">running</span><span class="p">);</span>
</pre></div></td>
        </tr>
      
        <tr>
          <td class="docs"><p>Undip. </p></td>
          <td class="code"><div class="highlight"><pre>
  <span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="n">pthread_mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">process</span><span class="p">.</span><span class="n">mutex</span><span class="p">);</span>
</pre></div></td>
        </tr>
      
        <tr>
          <td class="docs"><p>If we've decided to try a restart, call the abend handler. </p></td>
          <td class="code"><div class="highlight"><pre>
  <span class="k">if</span> <span class="p">(</span><span class="n">process</span><span class="p">.</span><span class="n">restarting</span><span class="p">)</span> <span class="p">{</span></pre></div></td>
        </tr>
      
        <tr>
          <td class="docs"><p>Call abend. </p></td>
          <td class="code"><div class="highlight"><pre>
    <span class="n">process</span><span class="p">.</span><span class="n">abend</span><span class="p">();</span>
</pre></div></td>
        </tr>
      
        <tr>
          <td class="docs"><p>If the abend handler did not call start, then it has decided to shutdown.
We are no longer restarting, and we can signal a process state change to
wake any library stub threads waiting on restart in shutdown.</p>

<p>Trigger both shutdown and running. The shutdown function waits to know
that the process has shutdown. Other functions wait for the process to
run again, and this will wake them so then can see that the process will
never run again. </p></td>
          <td class="code"><div class="highlight"><pre>
    <span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="n">pthread_mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">process</span><span class="p">.</span><span class="n">mutex</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">process</span><span class="p">.</span><span class="n">instance</span> <span class="o">==</span> <span class="n">instance</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">trace</span><span class="p">(</span><span class="s">&quot;terminate&quot;</span><span class="p">,</span> <span class="s">&quot;shutdown&quot;</span><span class="p">);</span>
      <span class="n">process</span><span class="p">.</span><span class="n">restarting</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
      <span class="n">process</span><span class="p">.</span><span class="n">shutdown</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
      <span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="n">pthread_cond_signal</span><span class="p">(</span><span class="o">&amp;</span><span class="n">process</span><span class="p">.</span><span class="n">cond</span><span class="p">.</span><span class="n">running</span><span class="p">);</span>
      <span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="n">pthread_cond_signal</span><span class="p">(</span><span class="o">&amp;</span><span class="n">process</span><span class="p">.</span><span class="n">cond</span><span class="p">.</span><span class="n">shutdown</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="n">pthread_mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">process</span><span class="p">.</span><span class="n">mutex</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></div></td>
        </tr>
      
        <tr>
          <td class="docs"><h3>Ready</h3>

<p><code>ready</code> &mdash; Called by the plugin stub after the initial call to start to
wait for the plugin server process to start.</p></td>
          <td class="code"><div class="highlight"><pre>
</pre></div></td>
        </tr>
      
        <tr>
          <td class="docs"><p>&#9824; </p></td>
          <td class="code"><div class="highlight"><pre>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">ready</span><span class="p">()</span> <span class="p">{</span>
  <span class="kt">int</span> <span class="n">ready</span><span class="p">;</span>
</pre></div></td>
        </tr>
      
        <tr>
          <td class="docs"><p>We block until either we are ready or have entered the shutdown state. If
we enter the shutdown state, we know that we will never run again. </p></td>
          <td class="code"><div class="highlight"><pre>
  <span class="n">pthread_mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">process</span><span class="p">.</span><span class="n">mutex</span><span class="p">);</span>
  <span class="k">while</span> <span class="p">(</span><span class="o">!</span> <span class="n">process</span><span class="p">.</span><span class="n">running</span> <span class="o">&amp;&amp;</span> <span class="o">!</span> <span class="n">process</span><span class="p">.</span><span class="n">shutdown</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">pthread_cond_wait</span><span class="p">(</span><span class="o">&amp;</span><span class="n">process</span><span class="p">.</span><span class="n">cond</span><span class="p">.</span><span class="n">running</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">process</span><span class="p">.</span><span class="n">mutex</span><span class="p">);</span>
  <span class="p">}</span>
  <span class="n">ready</span> <span class="o">=</span> <span class="o">!</span> <span class="n">process</span><span class="p">.</span><span class="n">shutdown</span><span class="p">;</span>
  <span class="n">pthread_mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">process</span><span class="p">.</span><span class="n">mutex</span><span class="p">);</span>

  <span class="n">trace</span><span class="p">(</span><span class="s">&quot;ready&quot;</span><span class="p">,</span> <span class="s">&quot;exit&quot;</span><span class="p">);</span>

  <span class="k">return</span> <span class="n">ready</span><span class="p">;</span>
<span class="p">}</span>
</pre></div></td>
        </tr>
      
        <tr>
          <td class="docs"><h3>Retry</h3></td>
          <td class="code"><div class="highlight"><pre>
</pre></div></td>
        </tr>
      
        <tr>
          <td class="docs"><p>Intialize thread local storage to keep a thread local copy of the instance
number of the plugin process server. We send the instance number to the
reaper thread to signal that we've detected a hung plugin process server. </p></td>
          <td class="code"><div class="highlight"><pre>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">allocate_instance_counter</span><span class="p">()</span> <span class="p">{</span>
  <span class="kt">int</span> <span class="o">*</span><span class="n">counter</span><span class="p">;</span>
  <span class="n">counter</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">));</span>
  <span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="mi">0</span><span class="p">;</span> <span class="cm">/* Docco thinks this is a comment -&gt; */</span>  <span class="o">*</span><span class="n">counter</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
  <span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="n">pthread_setspecific</span><span class="p">(</span><span class="n">process</span><span class="p">.</span><span class="n">key</span><span class="p">,</span> <span class="n">counter</span><span class="p">);</span>
<span class="p">}</span>
</pre></div></td>
        </tr>
      
        <tr>
          <td class="docs"><p>After initialization, the plugin server process is supposed to run, without
interruption, until the orderly shutdown of the plugin server process, prior
to unloading the plugin library.</p>

<p>The plugin attendant exists to launch the plugin server process, and to
restart it quickly in the event of an early, unexpected exit. The plugin
attendant will notice that the plugin server process has disappeared. It will
call the client supplied abend function, which can in turn tell the plugin
attendant to start the plugin server process, or it can descide to give up
and make the plugin unavailable.</p>

<p>Early, unexpected termination of the plugin server process creates the
potential for a disruption of server perceptible to the end user. This
potential cannot be eliminated.</p>

<p>Do not take this as an admonishment to write a plugin server process that
crashes never. Quite the opposite. The nice part about an out-of-process
architecture is that the consequences of failure are isolated. If you detect
that the plugin server process is in an invalid state, you can crash it and
get a new clean state. Leave a log behind and the new process can send a
crash report back to the mothership (with the end users's blessing) as its
first action on recovery.</p>

<p>You must, however, accept that there will be a seam in your plugin that the
user may have an occasion to see. You must develop a tolerence for
imperfection, because intolerence for imperfection is how crazy is made. A
belief that you have eleminated imperfection is the inevitable delusion. But,
we're not Java programmers here.</p>

<p>A strategy of crashing in response to exceptions means that you're plugin
server process needs to be reentrant. That is, you should be able to
terminate at any point, and the new process will be able to pick up the
peices and resume where you left off.</p>

<p>This is going to be hard to understand for those of you who are steeped in
the Kabuki of try/catch exception handling, or worse, checked exceptions.  It
is a different approach from try/catch exception handling. You build your
exception handling into your development cycle. You do not try to build it
into your function call stack.</p>

<p>A plugin server process that crashes when no one is looking will be restarted
by the plugin attendant. It will probably go unnoticed by the end user.</p>

<p>It is far more likely that the plugin server process will crash while
servicing a request of the plugin stub. The plugin stub will probably detect
the crash. It will need to wait for restart to retry the request on behalf of
the user.</p>

<p>The plugin stub is going to be using pipes, sockets or message queues to
communicate with the server process. Any reasonable method of IPC will have
ways to report that the other participant is missing, or offer a way to
timeout a request. The plugin stub must use these mechanisms to detect an
unresponsive server. It cannot take the presence of plugin process server for
granted.</p>

<p>There is no way for the plugin attendant to erect a barrier that the plugin
stub could rely upon to prevent it from connecting to a dead or hung plugin
process server. The crash may come at any time, perhaps at the moment just
before a pipe read. Rely instead on the operating system to report the
success or failure of inter-process communication.</p>

<p>The plugin stub may detect that the plugin server process has become
unresponsive. If the plugin server process is hung, the plugin attendant has
no way of knowing. In this case, the plugin stub will have to initiate an
early, unexpected shutdown, then wait for the restart.</p>

<p>This is, in fact, our default action when the plugin stub detects that the
plugin process server must restart. It signals to the plugin attendant that
the plugin attendant should restart the plugin process server, if the plugin
attendant hasn't already detected the failure itself.</p>

<p>The <code>retry</code> function of plugin attendant has a mechanism that will prevent a
race condition where the plugin attendant and one or more plugin stub threads
all discover that the plugin server process has crash, and all race to
restart it. In such a case, the plugin server process would be restarted more
than once for a single detected crash. This may lead to infinate restarts as
plugin threads would demand a restart of a crashed server, that was
crashed only because other plugin threads had just demanded the same.</p></td>
          <td class="code"><div class="highlight"><pre>
</pre></div></td>
        </tr>
      
        <tr>
          <td class="docs"><p><code>retry</code> &mdash; Report that IPC with the plugin server process failed,
indicating that the plugin server process is either crashed or hung.</p>

<p>The <code>retry</code> method will checks the last instance number of the plugin server
process known to the current thread. If the currently running plugin server
process has an instance number that is greater, retry will return true and
the plugin stub should retry communication with the plugin process server. If
the instance numbers are equal, and the plugin attendant believes that the
plugin server process is running, then the running flag is set to false, and
the reaper process is send the instance number through the instance pipe.</p></td>
          <td class="code"><div class="highlight"><pre>
</pre></div></td>
        </tr>
      
        <tr>
          <td class="docs"><p>&#9824; </p></td>
          <td class="code"><div class="highlight"><pre>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">retry</span><span class="p">(</span><span class="kt">int</span> <span class="n">milliseconds</span><span class="p">)</span> <span class="p">{</span>
  <span class="kt">int</span> <span class="n">err</span><span class="p">,</span> <span class="o">*</span><span class="n">instance</span><span class="p">,</span> <span class="n">terminate</span><span class="p">,</span> <span class="n">message</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span></pre></div></td>
        </tr>
      
        <tr>
          <td class="docs"><p>Initialize the thread local instance counter, once, to the number 1, the
first instance of plugin server process. </p></td>
          <td class="code"><div class="highlight"><pre>
  <span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="n">pthread_once</span><span class="p">(</span><span class="o">&amp;</span><span class="n">process</span><span class="p">.</span><span class="n">onceler</span><span class="p">,</span> <span class="n">allocate_instance_counter</span><span class="p">);</span>
</pre></div></td>
        </tr>
      
        <tr>
          <td class="docs"><p>Get the current value of the thread local instance. </p></td>
          <td class="code"><div class="highlight"><pre>
  <span class="n">instance</span> <span class="o">=</span> <span class="p">((</span><span class="kt">int</span><span class="o">*</span><span class="p">)</span> <span class="n">pthread_getspecific</span><span class="p">(</span><span class="n">process</span><span class="p">.</span><span class="n">key</span><span class="p">));</span> 
</pre></div></td>
        </tr>
      
        <tr>
          <td class="docs"><p>Dip into our mutex. </p></td>
          <td class="code"><div class="highlight"><pre>
  <span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="n">pthread_mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">process</span><span class="p">.</span><span class="n">mutex</span><span class="p">);</span>
</pre></div></td>
        </tr>
      
        <tr>
          <td class="docs"><p>If the process instance equals our thread local instance and the process is
running, then we are the first stub thread to report that this instance has
died. </p></td>
          <td class="code"><div class="highlight"><pre>
  <span class="k">if</span> <span class="p">(</span><span class="n">process</span><span class="p">.</span><span class="n">instance</span> <span class="o">==</span> <span class="o">*</span><span class="n">instance</span> <span class="o">&amp;&amp;</span> <span class="n">process</span><span class="p">.</span><span class="n">running</span><span class="p">)</span> <span class="p">{</span></pre></div></td>
        </tr>
      
        <tr>
          <td class="docs"><p>We are the only client thread that can reach this point. We mark the
plugin server process as not running. We will send a message to the
reaper thread to restart the plugin server thread, but outside of this
mutex. </p></td>
          <td class="code"><div class="highlight"><pre>
    <span class="n">process</span><span class="p">.</span><span class="n">running</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">terminate</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span></pre></div></td>
        </tr>
      
        <tr>
          <td class="docs"></td>
          <td class="code"><div class="highlight"><pre>
  <span class="p">}</span>
</pre></div></td>
        </tr>
      
        <tr>
          <td class="docs"><p>Undip. </p></td>
          <td class="code"><div class="highlight"><pre>
  <span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="n">pthread_mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">process</span><span class="p">.</span><span class="n">mutex</span><span class="p">);</span>
</pre></div></td>
        </tr>
      
        <tr>
          <td class="docs"><p>Send the instance number through the pipe. This wakes the reaper thread and
tells it that the given instance has hung. The reaper process will kill the
thread using SIGTERM, then SIGKILL.</p>

<p>TK Already awake.</p></td>
          <td class="code"><div class="highlight"><pre>
  <span class="k">if</span> <span class="p">(</span><span class="n">terminate</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">message</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="o">*</span><span class="n">instance</span><span class="p">;</span>
    <span class="n">message</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">milliseconds</span><span class="p">;</span>
    <span class="n">HANDLE_EINTR</span><span class="p">(</span><span class="n">write</span><span class="p">(</span><span class="n">process</span><span class="p">.</span><span class="n">pipes</span><span class="p">[</span><span class="n">PIPE_REAPER</span><span class="p">][</span><span class="mi">1</span><span class="p">],</span> <span class="n">message</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">message</span><span class="p">)),</span> <span class="n">err</span><span class="p">);</span> 
  <span class="p">}</span>
</pre></div></td>
        </tr>
      
        <tr>
          <td class="docs"><p>Wait for the server to be ready again. </p></td>
          <td class="code"><div class="highlight"><pre>
  <span class="k">if</span> <span class="p">(</span><span class="n">ready</span><span class="p">())</span> <span class="p">{</span></pre></div></td>
        </tr>
      
        <tr>
          <td class="docs"><p>Grab the instance number and shutdown state. </p></td>
          <td class="code"><div class="highlight"><pre>
    <span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="n">pthread_mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">process</span><span class="p">.</span><span class="n">mutex</span><span class="p">);</span>
    <span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="mi">0</span><span class="p">;</span> <span class="o">*</span><span class="n">instance</span> <span class="o">=</span> <span class="n">process</span><span class="p">.</span><span class="n">instance</span><span class="p">;</span>
    <span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="n">pthread_mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">process</span><span class="p">.</span><span class="n">mutex</span><span class="p">);</span>
</pre></div></td>
        </tr>
      
        <tr>
          <td class="docs"><p>Stash the instance number in thread local storage. </p></td>
          <td class="code"><div class="highlight"><pre>
    <span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="n">pthread_setspecific</span><span class="p">(</span><span class="n">process</span><span class="p">.</span><span class="n">key</span><span class="p">,</span> <span class="n">instance</span><span class="p">);</span>

    <span class="n">trace</span><span class="p">(</span><span class="s">&quot;retry&quot;</span><span class="p">,</span> <span class="s">&quot;again&quot;</span><span class="p">);</span>
</pre></div></td>
        </tr>
      
        <tr>
          <td class="docs"><p>Return true to indicate the IPC is running again. </p></td>
          <td class="code"><div class="highlight"><pre>
    <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="n">trace</span><span class="p">(</span><span class="s">&quot;retry&quot;</span><span class="p">,</span> <span class="s">&quot;shutdown&quot;</span><span class="p">);</span>
</pre></div></td>
        </tr>
      
        <tr>
          <td class="docs"><p>Return false if we've shutdown, indicating that a retry of IPC is
pointless. </p></td>
          <td class="code"><div class="highlight"><pre>
  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span></pre></div></td>
        </tr>
      
        <tr>
          <td class="docs"></td>
          <td class="code"><div class="highlight"><pre>
<span class="p">}</span>
</pre></div></td>
        </tr>
      
        <tr>
          <td class="docs"><h3>Shutdown</h3>

<p><code>shutdown</code> &mdash; Orderly shutdown is when we tell the plugin attendant to
expect an exit, and to not attempt to recover from the exit, it is the final
exit before the plugin is unloaded.</p>

<p>The happy path is as follows.</p>

<ul>
<li>The plugin stub calls shutdown to inform the plugin attendant that shutdown
is pending. The plugin attendant will not attempt restart the next time it
detects plugin server process shutdown.</li>
<li>The plugin stub should use its chosen method of IPC to inform the
server process to shutdown.</li>
<li>The plugin stub should then use the <code>done</code> function to wait for the
attendant to shutdown.</li>
</ul>

<p>This procedure should take place when the plugin library is unloaded. It must
be performed once and should not be called twice, or worse, at the same time
from multiple threads.</p>

<p>We assume that when the plugin stub calls shutdown that it is not waiting on
completion of calls to the plugin server process, and that it will make no
more calls to the plugin server process after shutdown is called.</p>

<p>The unhappy path is that the libary server process has crashed and is in
the midst of a recovery when the plugin stub calls initiates shutdown. The
plugin stub will use a form of IPC to request shutdown of a plugin server
process that is not running, that the plugin attendant is restarting.</p>

<p>The plugin stub should account for this condition. If the call to initiate an
orderly shutdown hangs up, call the <code>scram</code> function to terminate the plugin
server process with extreme prejudice. Then use the <code>done</code> function to wait
on exit.</p>

<p>We do not attempt to restart a crashed server so that we can tell it to
shutdown. You need to design a plugin server process that does not perform an
elaborate shutdown.</p></td>
          <td class="code"><div class="highlight"><pre>
</pre></div></td>
        </tr>
      
        <tr>
          <td class="docs"></td>
          <td class="code"><div class="highlight"><pre>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">shutdown</span><span class="p">()</span> <span class="p">{</span>
  <span class="kt">int</span> <span class="n">err</span><span class="p">,</span> <span class="n">running</span><span class="p">,</span> <span class="n">shutdown</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span> <span class="p">};</span>
</pre></div></td>
        </tr>
      
        <tr>
          <td class="docs"><p>Tell the reaper thread that shutdown has come. It will not attempt to
restart the library server process the next time it exits. </p></td>
          <td class="code"><div class="highlight"><pre>
  <span class="n">HANDLE_EINTR</span><span class="p">(</span><span class="n">write</span><span class="p">(</span><span class="n">process</span><span class="p">.</span><span class="n">pipes</span><span class="p">[</span><span class="n">PIPE_REAPER</span><span class="p">][</span><span class="mi">1</span><span class="p">],</span> <span class="n">shutdown</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">shutdown</span><span class="p">)),</span> <span class="n">err</span><span class="p">);</span>
</pre></div></td>
        </tr>
      
        <tr>
          <td class="docs"><p>Dip into our mutex to check and see we're not in the middle of a server
restart. If we are in the middle of a server restart, we may as well wait
for it to finish before we continue. </p></td>
          <td class="code"><div class="highlight"><pre>
  <span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="n">pthread_mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">process</span><span class="p">.</span><span class="n">mutex</span><span class="p">);</span>
  <span class="k">while</span> <span class="p">(</span><span class="n">process</span><span class="p">.</span><span class="n">restarting</span><span class="p">)</span> <span class="p">{</span>
    <span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="n">pthread_cond_wait</span><span class="p">(</span><span class="o">&amp;</span><span class="n">process</span><span class="p">.</span><span class="n">cond</span><span class="p">.</span><span class="n">running</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">process</span><span class="p">.</span><span class="n">mutex</span><span class="p">);</span>
  <span class="p">}</span>
</pre></div></td>
        </tr>
      
        <tr>
          <td class="docs"><p>Wait for the shutdown flag to set, otherwise a call to done is going to
report an invalid state. </p></td>
          <td class="code"><div class="highlight"><pre>
  <span class="k">while</span> <span class="p">(</span><span class="o">!</span> <span class="n">process</span><span class="p">.</span><span class="n">shutdown</span><span class="p">)</span> <span class="p">{</span>
    <span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="n">pthread_cond_wait</span><span class="p">(</span><span class="o">&amp;</span><span class="n">process</span><span class="p">.</span><span class="n">cond</span><span class="p">.</span><span class="n">shutdown</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">process</span><span class="p">.</span><span class="n">mutex</span><span class="p">);</span>
  <span class="p">}</span>
</pre></div></td>
        </tr>
      
        <tr>
          <td class="docs"><p>If we invoke the user abend function, and it doesn't want to restart, then
we will be both terminated and shutdown. We may have failed to launch the
process. The process may have launched and crashed, and the reaper did the
reaping befere this thread could make process. In any case, we are now
shutdown and terminated, so there is no point in trying to send a shutdown
signal to the never to be again library server process.</p>

<p>Also, even though we are in the running state, the process might be
crashing at this moment, so the orderly shutdown signal might not work. We
cant' say that it will work, but in certain cases we can say that it won't.</p></td>
          <td class="code"><div class="highlight"><pre>
</pre></div></td>
        </tr>
      
        <tr>
          <td class="docs"><p>Note if we are running. </p></td>
          <td class="code"><div class="highlight"><pre>
  <span class="n">running</span> <span class="o">=</span> <span class="n">process</span><span class="p">.</span><span class="n">running</span><span class="p">;</span>

  <span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="n">pthread_mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">process</span><span class="p">.</span><span class="n">mutex</span><span class="p">);</span>

  <span class="n">trace</span><span class="p">(</span><span class="s">&quot;shutdown&quot;</span><span class="p">,</span> <span class="s">&quot;exit&quot;</span><span class="p">);</span>

  <span class="k">return</span> <span class="n">running</span><span class="p">;</span>
<span class="p">}</span>
</pre></div></td>
        </tr>
      
        <tr>
          <td class="docs"><p>Want a timeout to escalate to kill. Or does kill happen in here? </p></td>
          <td class="code"><div class="highlight"><pre>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">done</span><span class="p">(</span><span class="kt">int</span> <span class="n">timeout</span><span class="p">)</span> <span class="p">{</span>
  <span class="kt">int</span> <span class="n">done</span><span class="p">,</span> <span class="n">shutdown</span><span class="p">;</span>

  <span class="n">pthread_mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">process</span><span class="p">.</span><span class="n">mutex</span><span class="p">);</span>
  <span class="k">if</span> <span class="p">((</span><span class="n">shutdown</span> <span class="o">=</span> <span class="n">process</span><span class="p">.</span><span class="n">shutdown</span><span class="p">))</span> <span class="p">{</span></pre></div></td>
        </tr>
      
        <tr>
          <td class="docs"><p>TODO Is this what we're waiting for? 
TODO Need to fix timeouts to that they try again if they exit early. </p></td>
          <td class="code"><div class="highlight"><pre>
    <span class="k">if</span> <span class="p">(</span><span class="n">process</span><span class="p">.</span><span class="n">running</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">do</span> <span class="p">{</span>
        <span class="n">pthread_cond_waitforabit</span><span class="p">(</span><span class="o">&amp;</span><span class="n">process</span><span class="p">.</span><span class="n">cond</span><span class="p">.</span><span class="n">running</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">process</span><span class="p">.</span><span class="n">mutex</span><span class="p">,</span> <span class="n">timeout</span><span class="p">);</span>
      <span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">process</span><span class="p">.</span><span class="n">running</span> <span class="o">&amp;&amp;</span> <span class="n">timeout</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">);</span>
    <span class="p">}</span>
  <span class="p">}</span>
  <span class="n">done</span> <span class="o">=</span> <span class="o">!</span> <span class="n">process</span><span class="p">.</span><span class="n">running</span><span class="p">;</span>
  <span class="n">pthread_mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">process</span><span class="p">.</span><span class="n">mutex</span><span class="p">);</span>
</pre></div></td>
        </tr>
      
        <tr>
          <td class="docs"><p>TODO Are you going to join a destroyed process? No, but multiple joins are
bad. TK Document that you can only call this from one thread. </p></td>
          <td class="code"><div class="highlight"><pre>
  <span class="k">if</span> <span class="p">(</span><span class="n">done</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">pthread_join</span><span class="p">(</span><span class="n">process</span><span class="p">.</span><span class="n">reaper</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
  <span class="p">}</span>

  <span class="n">trace</span><span class="p">(</span><span class="s">&quot;done&quot;</span><span class="p">,</span> <span class="s">&quot;exit&quot;</span><span class="p">);</span>

  <span class="k">return</span> <span class="n">done</span><span class="p">;</span>
<span class="p">}</span>
</pre></div></td>
        </tr>
      
        <tr>
          <td class="docs"><p>Shutdown immediately with a SIGKILL. </p></td>
          <td class="code"><div class="highlight"><pre>
</pre></div></td>
        </tr>
      
        <tr>
          <td class="docs"><p>TODO What is the correct return value? </p></td>
          <td class="code"><div class="highlight"><pre>
</pre></div></td>
        </tr>
      
        <tr>
          <td class="docs"></td>
          <td class="code"><div class="highlight"><pre>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">scram</span><span class="p">()</span> <span class="p">{</span>
  <span class="kt">int</span> <span class="n">err</span><span class="p">,</span> <span class="n">scram</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span> <span class="n">INT_MAX</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span> <span class="p">};</span></pre></div></td>
        </tr>
      
        <tr>
          <td class="docs"><p>Must be able to send two shutdowns. Then poll must be able to detect that
not all of the stuff has been read, poll must not block if the buffer is
not drained. </p></td>
          <td class="code"><div class="highlight"><pre>
  <span class="k">if</span> <span class="p">(</span><span class="n">shutdown</span><span class="p">())</span> <span class="p">{</span></pre></div></td>
        </tr>
      
        <tr>
          <td class="docs"><p>Send a huge instance number down the pipe. This is going to trigger a
restart, an unrecoverable one, and a last one. No other <code>scram</code> or
<code>retry</code> will be able to trigger a restart, because they will not be able
to send a greater instance number to supersede the maxium instance number
send by this <code>scram</code>.</p>

<p>We'll try a SIGTERM term first, as usual, then a SIGKILL.</p></td>
          <td class="code"><div class="highlight"><pre>
    <span class="n">HANDLE_EINTR</span><span class="p">(</span><span class="n">write</span><span class="p">(</span><span class="n">process</span><span class="p">.</span><span class="n">pipes</span><span class="p">[</span><span class="n">PIPE_REAPER</span><span class="p">][</span><span class="mi">1</span><span class="p">],</span> <span class="n">scram</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">scram</span><span class="p">)),</span> <span class="n">err</span><span class="p">);</span>

    <span class="n">trace</span><span class="p">(</span><span class="s">&quot;scram&quot;</span><span class="p">,</span> <span class="s">&quot;initiated&quot;</span><span class="p">);</span>

    <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="n">trace</span><span class="p">(</span><span class="s">&quot;scram&quot;</span><span class="p">,</span> <span class="s">&quot;shutdown&quot;</span><span class="p">);</span>

  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div></td>
        </tr>
      
        <tr>
          <td class="docs"><p>TODO </p></td>
          <td class="code"><div class="highlight"><pre>
<span class="k">static</span> <span class="kt">int</span><span class="o">*</span> <span class="nf">errors</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>
</pre></div></td>
        </tr>
      
        <tr>
          <td class="docs"><p>Called when the library unloaded. This will not shutdown the server process.
You must shutdown the server process, though. Do that before calling destroy.</p></td>
          <td class="code"><div class="highlight"><pre>
</pre></div></td>
        </tr>
      
        <tr>
          <td class="docs"><p>&#9824; &mdash; </p></td>
          <td class="code"><div class="highlight"><pre>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">destroy</span><span class="p">()</span> <span class="p">{</span>
  <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
</pre></div></td>
        </tr>
      
        <tr>
          <td class="docs"><p>Release our mutex and signaling devices. </p></td>
          <td class="code"><div class="highlight"><pre>
  <span class="n">pthread_mutex_destroy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">process</span><span class="p">.</span><span class="n">mutex</span><span class="p">);</span>
  <span class="n">pthread_cond_destroy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">process</span><span class="p">.</span><span class="n">cond</span><span class="p">.</span><span class="n">running</span><span class="p">);</span>
  <span class="n">pthread_cond_destroy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">process</span><span class="p">.</span><span class="n">cond</span><span class="p">.</span><span class="n">shutdown</span><span class="p">);</span>
  <span class="n">pthread_cond_destroy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">process</span><span class="p">.</span><span class="n">cond</span><span class="p">.</span><span class="n">getgpid</span><span class="p">);</span>
</pre></div></td>
        </tr>
      
        <tr>
          <td class="docs"><p>Release the path to the relay program. </p></td>
          <td class="code"><div class="highlight"><pre>
  <span class="n">free</span><span class="p">(</span><span class="n">process</span><span class="p">.</span><span class="n">relay</span><span class="p">);</span>
  <span class="n">process</span><span class="p">.</span><span class="n">relay</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</pre></div></td>
        </tr>
      
        <tr>
          <td class="docs"><p>Release the file descriptors reserved for the plugin stub side of the stdio
pipes. </p></td>
          <td class="code"><div class="highlight"><pre>
  <span class="n">close</span><span class="p">(</span><span class="n">process</span><span class="p">.</span><span class="n">pipes</span><span class="p">[</span><span class="n">PIPE_STDIN</span><span class="p">][</span><span class="mi">1</span><span class="p">]);</span>
  <span class="n">close</span><span class="p">(</span><span class="n">process</span><span class="p">.</span><span class="n">pipes</span><span class="p">[</span><span class="n">PIPE_STDOUT</span><span class="p">][</span><span class="mi">0</span><span class="p">]);</span>
  <span class="n">close</span><span class="p">(</span><span class="n">process</span><span class="p">.</span><span class="n">pipes</span><span class="p">[</span><span class="n">PIPE_STDERR</span><span class="p">][</span><span class="mi">0</span><span class="p">]);</span>
</pre></div></td>
        </tr>
      
        <tr>
          <td class="docs"><p>Release the reaper pipe. </p></td>
          <td class="code"><div class="highlight"><pre>
  <span class="n">close</span><span class="p">(</span><span class="n">process</span><span class="p">.</span><span class="n">pipes</span><span class="p">[</span><span class="n">PIPE_REAPER</span><span class="p">][</span><span class="mi">0</span><span class="p">]);</span>
  <span class="n">close</span><span class="p">(</span><span class="n">process</span><span class="p">.</span><span class="n">pipes</span><span class="p">[</span><span class="n">PIPE_REAPER</span><span class="p">][</span><span class="mi">1</span><span class="p">]);</span>
</pre></div></td>
        </tr>
      
        <tr>
          <td class="docs"><p>Release the trace points, if any. </p></td>
          <td class="code"><div class="highlight"><pre>
<span class="cp">#ifdef _DEBUG</span>
  <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">process</span><span class="p">.</span><span class="n">trace</span><span class="p">.</span><span class="n">points</span><span class="p">[</span><span class="n">i</span><span class="p">];</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">free</span><span class="p">(</span><span class="n">process</span><span class="p">.</span><span class="n">trace</span><span class="p">.</span><span class="n">points</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
  <span class="p">}</span>

  <span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="n">pthread_mutex_destroy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">process</span><span class="p">.</span><span class="n">trace</span><span class="p">.</span><span class="n">mutex</span><span class="p">);</span>
<span class="cp">#endif</span>

  <span class="n">trace</span><span class="p">(</span><span class="s">&quot;scram&quot;</span><span class="p">,</span> <span class="s">&quot;success&quot;</span><span class="p">);</span>
</pre></div></td>
        </tr>
      
        <tr>
          <td class="docs"><p>Success. </p></td>
          <td class="code"><div class="highlight"><pre>
  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
</pre></div></td>
        </tr>
      
        <tr>
          <td class="docs"><p>&mdash; </p></td>
          <td class="code"><div class="highlight"><pre>
<span class="p">}</span>

<span class="k">struct</span> <span class="n">attendant</span> <span class="n">attendant</span> <span class="o">=</span>
<span class="p">{</span> <span class="n">initalize</span>
<span class="p">,</span> <span class="n">start</span>
<span class="p">,</span> <span class="n">ready</span>
<span class="p">,</span> <span class="n">stdio</span>
<span class="p">,</span> <span class="n">retry</span>
<span class="p">,</span> <span class="n">shutdown</span>
<span class="p">,</span> <span class="n">done</span>
<span class="p">,</span> <span class="n">scram</span>
<span class="p">,</span> <span class="n">errors</span>
<span class="p">,</span> <span class="n">destroy</span>
<span class="cp">#ifdef _DEBUG</span>
<span class="p">,</span> <span class="n">tracepoints</span>
<span class="cp">#endif</span>
<span class="p">};</span>
</pre></div></td>
        </tr>
      
        <tr>
          <td class="docs"><p>Had a realization while considering restart. I'd initially thought that I'd
leave it to the client programmer to choose between polling or an abend
callback, but in the end I realized that I don't have to support a use case
that I'm not going to use. This is me imaginging someone chastising me for
not offering an option, an arbitrary option, that occured to me out of
nowhere. To my mind, someone will request this someday, so I'd better think
about it now.</p>

<p>Who? When? And why must I now design this for them? Why must I test it?  Why
is it on me to support the mythical guy shouting gimmie in my inbox someday?
They ought to provide the patch, the tests, and the justification for adding
a logical paths that do not yet exist.</p></td>
          <td class="code"><div class="highlight"><pre>
</pre></div>
</pre></div></td>
        </tr>
      
    </tbody>
  </table>
</div>
</body>
</html>
