<!DOCTYPE html>
<html>
<head>
<title></title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<link rel="stylesheet" media="all" href="/attendant/css/docco.css">
</head>
<body>
<div id="container">
<div id="background"></div>
<!DOCTYPE html>

<html>
<head>
  <title>./attendant.h</title>
  <meta http-equiv="content-type" content="text/html; charset=UTF-8">
  <link rel="stylesheet" media="all" href="/attendant/css/docco.css">
</head>
<body>
<div id="container">
<a href="http://github.com/bigeasy/strata"><img
  style="position: fixed; top: 0; right: 0; border: 0;"
  src="http://s3.amazonaws.com/github/ribbons/forkme_right_orange_ff7600.png" alt="Fork me on GitHub" /></a>
<div id="background"></div>
  <table cellspacing="0" cellpadding="0">
    <thead>
      <tr>
        <th class="docs"><h1></th>
        <th class="code"></th>
      </tr>
    </thead>
    <tbody>
      
        <tr>
          <td class="docs"><p>A process monitor that watches a single out-of-process server on behalf of a
dynamically loaded plugin running within the context of a host application. </p>

<h2>On Documentation</h2>

<p>I'm documenting what I've written. I'm not defending what I've written. If
you think you can do better, submit a patch. If I disagree, then fork. If you
find a bug, tell me, please. Otherwise, before you tell me that there is
something wrong, try to make sure you understand the inherient compromises.</p>

<p>It took a longer to write this than I would have expected. If you don't have
time to read the documentation, I can't read it to you. If you were to email
me directly, I might type out something just about as long. But, please, do
ask questions, and suggest documentation patches if this is confusing.</p>

<p>&mdash;</p>

<p><em>Now Helicon must needs pour forth for me, And with her choir Urania must
assist me, To put in verse things difficult to think.</em> &mdash; Dante</p>

<h2>Origins</h2>

<p>The plugin attendant was written for use in an
<a href="https://wiki.mozilla.org/NPAPI">NPAPI</a> plugin, but there is no NPAPI
specific code here. There are no NPAPI function calls or header files.</p>

<p>I imagine that this plugin attendant could work with any similar plugin
architecture, where a host application loads a plugin that is implemented as
dynamically linked library.</p>

<p>If you've found this, you've probably discovered that it is no simple matter
to launch a process from an NPAPI plugin, let alone monitor it, signal it,
and obtain its exit status. It really is not that simple.</p>

<h2>Purpose</h2>

<p>The plugin attendant launches and monitors a single process.</p>

<p>With this single process, you can implement an out-of-process plugin
architecture. Your plugin functions as a proxy to an out-of-process plugin
server that performs the real work of the plugin. It isolates the complexity
of the plugin in a separate process, so that a catastrophic error will
destabilize only the plugin server, and not destabilize the host application.</p>

<p>The out-of-process architecture divides a plugin into a plugin stub, a plugin
attendant, and a plugin server process. The plugin stub is the library loaded
by the host application that implements the plugin interface according to the
plugin API. The plugin server process is an out-of-process service that
implements the plugin logic. The plugin attendent, seen here, monitors the
process, restarting it if it exists unexpectedly.</p>

<p>Within its out-of-process container, your plugin is free to do whatever it
wants, to take whatever shape it needs to take. It is not limited by the
architecture of the host application. It has its own process space. It
doesn't have to worry about deadlock against and races with unknown host
application threads. It can use the full compilment of services available to
it on its host operating system.</p>

<h2>Usage</h2>

<p>The plugin attendant launches plugin server process when the plugin library
loads. It monitors the plugin server process while the plugin is in service.
It terminates the plugin server process when the plugin unloads.</p>

<p>Although technically a child process on UNIX, the plugin server process does
not act as a child in the classic pre-fork worker architecture. The plugin
server acts as a daemon, an isolated and entirely separate process running on
the same machine as the plugin stub. It may as well have been launched by the
operating system as a system service. </p>

<p>The plugin attendant does not provide a framework for an out-of-process
plugin architecture. It does provide the essential service of launching and
monitoring the external server from within the host application. It does not
provide a inter-process communication strategy. You can use the IPC
facilities of your operating system to design an ideal strategy for your
plugin.</p>

<p>The plugin attendant maintains a set of redirected standard I/O pipes,
standard input, standard output, and standard error. These pipes serve as the
minimum inter-process communication channel between the plugin stub and the
plugin server process. You can use standard I/O and command line arguments to
estabish furher inter-process communication channels, using other operating
system facilities such as message queues, named pipes and TCP/IP sockets.</p>

<p>You might decide that standard I/O is sufficient for inter-process
communication between your plugin stub and the plugin server process. You are
still responsible for desiging a protocol that will use the standard I/O
pipes.</p>

<h2>Plugin Server Process Requirements</h2>

<p>The plugin server process will be like so...</p>

<ul>
<li>There is one and only one instance of the plugin server process to monitor.</li>
<li>You'll know exactly where the program file is on the file system before you
try to start it. No search paths here.</li>
<li>The plugin server process runs as long as the library is loaded and it
shuts down when the library is unloaded.</li>
<li>On UNIX, the plugin server process will inherit an open file descriptor,
with a file descriptor number of your choice. It is a canary file descriptor
used to detect plugin server process exit. The plugin server process will not
read from, write to, or close the file descriptor.</li>
<li>The plugin stub uses some means of IPC to communicate with the plugin
server process as if the sever process were a system daemon.</li>
<li>The orderly shutdown plugin server process is initated though an IPC call,
not though signals, because Windows doesn't have signals.</li>
<li>The plugin server process will shutdown fast, in under 500 milliseconds.</li>
<li>The plugin server will be reentrant.</li>
</ul>

<p>If your plugin server process cannot exhibit this behavior, create a plugin
server process that can exhibit this behavior and have it be the one to
manage your aberant plugin server process.</p>

<h2>Difficulties</h2>

<p>It is difficult to implement process monitoring in fashion that</p>

<ul>
<li>is portable across Widows and all flavors of UNIX, </li>
<li>cannot assume control of process monitoring facilities, and</li>
<li>works within a host application that might be surpised by the presence of a
child proess that it did not create.</li>
</ul>

<p>A plugin may be loaded into any application that implements the targeted
plugin API. This means that your plugin may be loaded into host applications
with different appliciation architectures.</p>

<p>You might be in a multi-threaded application, where forked proceses can only
make async-safe system calls, anything less is thread-unsafe. It is
impossible to implement a traditional forked worker when threading is
employed. This is why we launch a whole new program and treat it as a daemon,
instead of a worker.</p>

<p>You might be in an multi-process application that has registered its own
signal handlers, and treats your child process as one of its own workers.
You don't have control over signal handlers. You don't know who's going to
reap your child process.</p>

<p>In both cases, you don't know what file descriptors your plugin worker
process will inherit.</p>

<p>Of course, none of this applies to Windows. With Windows the problem is that
there is no such thing as a child process. A process is isolated from the
process that started it entirely. There is no signal handling, and therefore
no way to signal an orderly shutdown.</p>

<p>In order to reliable use the standard in pipe to send data to the plugin
server process on UNIX, the host application must have the signal handler for
<code>SIGPIPE</code> set to <code>SIG_IGN</code>. Writing to the pipe when the plugin process
server has closed will cause a <code>SIGPIPE</code> signal. If there is no <code>SIGPIPE</code>
handler in place, then the unhandled <code>SIGPIPE</code> will cause the host
application to terminate.</p>

<p>If there is a <code>SIGPIPE</code> handler in place, then the host application will
handle a <code>SIGPIPE</code> from a child that it did not create. Testing may determine
that this is not an issue, that the registered handler is doing the right
thing.</p>

<p>OS X offers a per file descriptor flag that disables SIGPIPE, but this is not
available on Linux.</p>

<p>You can add a test to your plugin where it writes to a pipe with a closed
read file descriptor. If the host application disappears when your plugin is
loaded, it is not handling <code>SIGPIPE</code> gracefully.</p>

<p>If this is the case, you should not use the standard in pipe. You can still
use read from standard out and standard error. You can still send data to
your plugin server process through program arguments. Using program arguments
and standard output, you can bootstrap a more robust form of IPC. UNIX domain
sockets, for example, can disable <code>SIGPIPE</code> on a per socket basis, regardless
of the disposition of the <code>SIGPIPE</code> signal handlers.</p>

<p>Our ideal UNIX host application would set a benign child handler to handle
<code>SIGCHLD</code>, or leave it the default. It would use <code>waitpid</code> to wait only on
the exit of child processes that it created itself, allowing the plugin to
use <code>waitpid</code> to wait on the exit of the plugin process server. It elminate
<code>SIGPIPE</code> signals by  setting its <code>SIGPIPE</code> handler set to the <code>SIG_IGN</code>
disposition.</p>

<h2>How It Works</h2>

<p>On UNIX, the plugin server process inherits a file descriptor that is the
write end of a pipe. The plugin server process must not write to this file
descriptor, nor close it. The file descriptor will close when the plugin
server process exits. The plugin attendant listens for the <code>EPIPE</code>. When it
arrives it knows that the the plugin server process has terminated.</p>

<p>The pipe used to detect plugin server process termination is called the
canary pipe.</p>

<p>This is how we get around a host application that has disabled child signals,
or is waiting for all children and intercepting out exit signals.</p>

<p>On Windows we have a handle to the plugin server process and we wait for
termination normally.</p>

<h2>Life Cycle</h2>

<p>The plugin attendant implements the following life cycle.</p>

<p>These actions take place during library load.</p>

<p>&#9824; &nbsp; <code>initialize</code> &mdash; The plugin is loaded and the library
initailization function calls the plugin attendant <code>initialize</code> function.</p>

<p>&#9824; &nbsp; <code>start</code> &dash; Immediately after calling <code>initialize</code>, the
plugin stub calls the <code>start</code> function to execute what we hope will be the
only instance of the plugin server process we'll need.</p>

<p>Library load is over. You should return control to the host application now.</p>

<p>&#9824; &nbsp; <code>ready</code> &dash; Called when the host applications requests
service from the plugin. It will block until the plugin server process has
started running.</p>

<p>We allow the plugin developer to decide what to do when the plugin server
process crashes.</p>

<p>&#9824; &nbsp; <code>abend</code> &dash; Is as plugin developer provided function that
is called when the plugin attendant detects that the plugin server process
has crashed. The <code>abend</code> function can opt to call the <code>start</code> function again
to restart the plugin server process. If it does not call the <code>start</code>
function, the plugin attendant goes into a final shutdown state.</p>

<p>The plugin stub might be first to detect a problem with the plugin server
process, being cut off in the middle of IPC, or else discovering that that
the plugin server process, while running is otherwise unresponsive.</p>

<p>&#9824; &nbsp; <code>retry</code> &dash; Called by the plugin stub after IPC fails. The
function blocks until the plugin attendant successfully restarts the plugin
server process, or alternatively, the plugin attendant enters the final
shutdown state. If the <code>retry</code> method return true, IPC should be retryed. IPC
should be retryed until <code>retry</code> returns false.</p>

<p>Shutdown occurs when the host application unloads the plugin library in the
library deinitialization function. The plugin attendant does not send a
shutdown signal to the plugin server process. Orderly shutdown is initated
through IPC between the plugin stub and the plugin server process.</p>

<p>&#9824; &nbsp; <code>shutdown</code> &mdash; Called by the plugin stub to inform the
plugin attendant that the next plugin server process exit is expected.</p>

<p>&#9824; &nbsp; <code>done</code> &mdash; Called by the plugin stub with a timeout
duration to wait for the plugin server process to terminate.</p>

<p>&#9824; &nbsp; <code>scram</code> &mdash; If the <code>done</code> function times out, the plugin
stub should call <code>scram</code> to forcibly terminate the plugin server process. It
can then wait on <code>done</code> without a timeout.</p>

<p>When the plugin attendant enters the shutdown state, it cannot exit that
state. The plugin server process will not run until the plugin library is
reloaded by the host application, or the host application is restarted.</p>

<p>&#9824; &nbsp; <code>destroy</code> &mdash; Called after the plugin attendant has
entered the shutdown state, prior the library unload, to release a smidge of
memory.</p>

<h2>Limitations</h2>

<p>If the host application does not ignore <code>SIGPIPE</code>, the plugin stub cannot
rely on the <code>stdin</code> pipe to send data to the plugin server process.</p>

<p>You could endavour to write a plugin server process that itself will not
crash, a minimal plugin server process, that in turn monitors the workhorse
plugin server process, but I'm sure you're going to find a few more
difficulties at that level in any case.</p>

<p>There are limitations to what an out-of-process server can do. If the plugin
is supposed to draw a region of a window in a desktop application, for
example, the plugin process might be able to render a image to fill the
region, but plugin stub would have to implement the actual GDI calls to paint
the image into the region on the screen.</p>

<h2>Limitations That Aren't</h2>

<p>The plugin attendant monitors your process even thought it might not be able
to do traditional process monitoring because the host application has
employed signals and is waiting on all child processes for its own process
monitoring needs. The same plugin attendant API works on both Windows and
multiple flavors of UNIX. With these requirements, there are some practical
limitations, that ought not truly limit your abilities.</p>

<p>&#9824; &nbsp; The plugin attendant monitors a single plugin server process. The
plugin attendant has to accomodate a host application that has reserved the
process monitoring for itself. Its method of monitoring the plugin server
process is dedicated to reducing conflicts between the host application and
the plugin server process. It is not the robust, general purpose process
monitoring you get with <code>systemd</code>, <code>perl</code> or <code>bash</code>.</p>

<p>If you need to launch multiple processes to service your plugin, then make
the first process you launch a process that monitors your flock of processes.
Your plugin server process can assume full control of the process monitoring
facilities to manage the flock.</p>

<p>&#9824; &nbsp; The plugin attendant does its best to be as unobtrusive as possible,
but there are some aggressive actions that it cannot survive. The host
application must not close our standard I/O pipes, our canary pipe, and it
must not signal our process.</p></td>
          <td class="code"><div class="highlight"><pre></pre></div></td>
        </tr>
      
        <tr>
          <td class="docs"><p>&mdash; </p></td>
          <td class="code"><div class="highlight"><pre>
</pre></div></td>
        </tr>
      
        <tr>
          <td class="docs"><p>Written in C. </p></td>
          <td class="code"><div class="highlight"><pre>
<span class="cp">#ifdef __cplusplus</span>
<span class="k">extern</span> <span class="s">&quot;C&quot;</span> <span class="p">{</span>
<span class="cp">#endif </span>

<span class="k">struct</span> <span class="n">attendant__errors</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">attendant</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">system</span><span class="p">;</span>
<span class="p">};</span>
</pre></div></td>
        </tr>
      
        <tr>
          <td class="docs"><p>On UNIX a pipe is a file descriptor. On Windows, a pipe a <code>HANDLE</code>. </p></td>
          <td class="code"><div class="highlight"><pre>
<span class="cp">#ifdef _WIN32</span>
<span class="k">typedef</span> <span class="n">HANDLE</span> <span class="n">attendant__pipe_t</span><span class="p">;</span>
<span class="cp">#else</span>
<span class="k">typedef</span> <span class="kt">int</span> <span class="n">attendant__pipe_t</span><span class="p">;</span>
<span class="cp">#endif</span>

<span class="k">struct</span> <span class="n">attendant__initializer</span> <span class="p">{</span>
  <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">starter</span><span class="p">)(</span><span class="kt">int</span> <span class="n">restart</span><span class="p">);</span>
  <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">connector</span><span class="p">)(</span><span class="n">attendant__pipe_t</span> <span class="n">in</span><span class="p">,</span> <span class="n">attendant__pipe_t</span> <span class="n">out</span><span class="p">);</span></pre></div></td>
        </tr>
      
        <tr>
          <td class="docs"><p>The full path to the plugin attendant relay program. This program will
ensure that all file handles are closed and signal handlers reset. It the
responsibility of the plugin developer to distribute the relay program and
make it available to the plugin attendnat. </p></td>
          <td class="code"><div class="highlight"><pre>
  <span class="kt">char</span> <span class="n">relay</span><span class="p">[</span><span class="n">FILENAME_MAX</span><span class="p">];</span></pre></div></td>
        </tr>
      
        <tr>
          <td class="docs"></td>
          <td class="code"><div class="highlight"><pre>
<span class="cp">#ifndef _WIN32</span></pre></div></td>
        </tr>
      
        <tr>
          <td class="docs"><p>The file descriptor number for the plugin server process side of the canary
pipe. Must not conflict with the file descriptor numbers assinged to
standard I/O by the operating system. The plugin developer has the option
to specify the file descriptor number to avoid any conflicts. If you don't
care, then make an arbitrary decision. </p></td>
          <td class="code"><div class="highlight"><pre><span class="cp"></span>
  <span class="n">attendant__pipe_t</span> <span class="n">canary</span><span class="p">;</span></pre></div></td>
        </tr>
      
        <tr>
          <td class="docs"></td>
          <td class="code"><div class="highlight"><pre>
<span class="cp">#endif</span></pre></div></td>
        </tr>
      
        <tr>
          <td class="docs"><p>&mdash; </p></td>
          <td class="code"><div class="highlight"><pre><span class="cp"></span>
<span class="p">};</span>
</pre></div></td>
        </tr>
      
        <tr>
          <td class="docs"><p>There is one instance of the plugin attendant that monitors only one instance
of the plugin server process. The plugin attendant functions are contained
within a structure which emulates a namespace. The plugin attendant functions
are called by referencing them within the structure. An invocation of the
plugin attendant function would appear as <code>attendant.initialize()</code> in client
code.</p></td>
          <td class="code"><div class="highlight"><pre>
</pre></div></td>
        </tr>
      
        <tr>
          <td class="docs"></td>
          <td class="code"><div class="highlight"><pre>
<span class="k">struct</span> <span class="n">attendant</span> <span class="p">{</span></pre></div></td>
        </tr>
      
        <tr>
          <td class="docs"><p><code>initialize</code> &mdash; This must be called to initialize the the monitor
before any other functions are called. Call <code>initialize</code> during the global
initialization of your library, followed by the initial call to <code>start</code>.</p>

<p>TODO Re-docco.</p></td>
          <td class="code"><div class="highlight"><pre>
</pre></div></td>
        </tr>
      
        <tr>
          <td class="docs"><p>&#9824; </p></td>
          <td class="code"><div class="highlight"><pre>
  <span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">initialize</span><span class="p">)(</span><span class="k">struct</span> <span class="n">attendant__initializer</span> <span class="o">*</span><span class="n">initializer</span><span class="p">);</span>
</pre></div></td>
        </tr>
      
        <tr>
          <td class="docs"><p><code>start</code> &mdash; Called to start the plugin process server when the plugin
library is loaded. Also called from within the plugin developer provided
abend function to restart the plugin in the event of an early, unexpected
restart.</p>

<p>The <code>start</code> function can be called by the <code>abend</code> function, if the <code>abend</code>
function decides to restart the plugin server process. The <code>abend</code> function
should only call the <code>start</code> function once in response to an abnormal exit.</p>

<p>Otherwise, the <code>start</code> function should only be called once outside of the
<code>abend</code> function, to start the plugin process server when the plugin
library loads.</p>

<p>The abend callback must take precautions to be thread safe. It will be
called from a different thread than the thread that performed the first
call to the <code>start</code> function. If you need to reference variables shared by
the rest of your plugin stub, those variables need to be gaurded by a
mutex.</p>

<p>After the plugin attendant enters the shutdown state, it cannot be
restarted. See the <code>shutdown</code> function for more details on the shutdown
state.</p>

<p>TODO Re-docco.</p></td>
          <td class="code"><div class="highlight"><pre>
</pre></div></td>
        </tr>
      
        <tr>
          <td class="docs"><p>&#9824; </p></td>
          <td class="code"><div class="highlight"><pre>
  <span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">start</span><span class="p">)(</span></pre></div></td>
        </tr>
      
        <tr>
          <td class="docs"><p>The aboslute path to plugin server program. </p></td>
          <td class="code"><div class="highlight"><pre>
    <span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">path</span><span class="p">,</span></pre></div></td>
        </tr>
      
        <tr>
          <td class="docs"><p>A null terminated array of program arguments. </p></td>
          <td class="code"><div class="highlight"><pre>
    <span class="kt">char</span> <span class="k">const</span><span class="o">*</span> <span class="n">argv</span><span class="p">[]</span></pre></div></td>
        </tr>
      
        <tr>
          <td class="docs"><p>&mdash; </p></td>
          <td class="code"><div class="highlight"><pre>
  <span class="p">);</span>
</pre></div></td>
        </tr>
      
        <tr>
          <td class="docs"><p><code>ready</code> &mdash; Called after the initial call to <code>start</code> to wait for the
plugin server process to start before IPC.</p>

<p>The <code>ready</code> function should guard any function that could be called by the
host application after library load. If your plugin API has a subsequent
initialization function after library load, like a plugin object
constructor, you can place a call to <code>ready</code> there.</p>

<p>If the host application can call any plugin function after library load,
you'll have to call <code>ready</code> at the start of every function. A call to
<code>ready</code> is not expensive, though, so don't contort your plugin to avoid
calling it.</p>

<p>The <code>ready</code> function blocks until the plugin server process has started.
There may still be a race condition where the plugin stub makes a call to
the plugin server process over an IPC channel that the plugin server
process has yet to initialize. To avoid this race condition, you could use
the stdout pipe to listen for an okay of some kind form the plugin server
process.</p>

<p>The standard I/O pipes will be established when the <code>ready</code> function
returns true.</p>

<p>If the <code>ready</code> function returns false the plugin attendant has entered the
final shutdown state and the plugin process will never run. This would be
due to a catastrophic error, such a missing plugin server program file.</p></td>
          <td class="code"><div class="highlight"><pre>
</pre></div></td>
        </tr>
      
        <tr>
          <td class="docs"><p>&#9824; </p></td>
          <td class="code"><div class="highlight"><pre>
  <span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">ready</span><span class="p">)();</span>
</pre></div></td>
        </tr>
      
        <tr>
          <td class="docs"><p><code>retry</code> &mdash; Report that IPC with the plugin server process failed,
indicating that the plugin server process is either crashed or hung.</p>

<p>Calling <code>retry</code> will cause the plugin attendant to initiate a restart of
the plugin server process. It will not initiate a restart if it hasn't
already detected the plugin server process failure itself. </p>

<p>The <code>retry</code> function is thread-safe. Multiple plugin stub threads can
report that the plugin process server is missing or unresponsive. The
plugin attendant will only restart the plugin server once.</p>

<p>The <code>retry</code> function blocks until the plugin attendant successfully
restarts the plugin server process, or alternatively, the plugin attendant
enters the final shutdown state. If the <code>retry</code> function return true, IPC
should be retryed. IPC should be retryed until IPC succeeds, or <code>retry</code>
returns false.</p>

<p>If <code>retry</code> returns false, the plugin attendant has entered the final
shutdown state. The plugin server process will not be restarted. The reason
may be obtained using the <code>errors</code> function. If the attendant error code is
<code>0</code>, that indicates that there is no error, and the plugin attendant
entered the final shutdown state due to an orderly shutdown. </p></td>
          <td class="code"><div class="highlight"><pre>
</pre></div></td>
        </tr>
      
        <tr>
          <td class="docs"><p>&#9824; </p></td>
          <td class="code"><div class="highlight"><pre>
  <span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">retry</span><span class="p">)(</span><span class="kt">int</span> <span class="n">millis</span><span class="p">);</span>
</pre></div></td>
        </tr>
      
        <tr>
          <td class="docs"><p><code>shutdown</code> &mdash; Inform the plugin attendant that shutdown time has come
and that the next plugin server process is expected.</p>

<p>The plugin attendant does not signal the plugin process server to shutdown
itself. The plugin stub must tell the plugin server process to shutdown
through some form of IPC.</p>

<p>The <code>shutdown</code> function only informs the the plugin attendant that it
should no longer treat plugin server process exit as abnormal. That is
should no longer attempt to restart the plugin server process.</p>

<p>Once in the shutdown state, the plugin server process cannot be restarted
by the currently loaded plugin library. The plugin server process will not
run again until the plugin library is reloaded or the host application is
restrated.</p>

<p>The plugin attendant will enter the shutdown state in response to a call to
the <code>shutdown</code> function, the <code>scram</code> function, or if the plugin developer
supplied <code>abend</code> function does not call the <code>start</code> function to restart the
server.</p>

<p>Additionally, the plugin attendant will enter the shutdown state in
response to failed assertions. If the <code>start</code> function fails, or <code>retry</code>
function fails, you should inspect the errors using the <code>errors</code> function,
record them, and tell me about them.</p>

<p>Returns false if the plugin server process shutdown and will not run again.
Returns true if the plugin server process is running, or not running but
potentially restarting.</p></td>
          <td class="code"><div class="highlight"><pre>
</pre></div></td>
        </tr>
      
        <tr>
          <td class="docs"><p>&#9824; </p></td>
          <td class="code"><div class="highlight"><pre>
  <span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">shutdown</span><span class="p">)();</span>
</pre></div></td>
        </tr>
      
        <tr>
          <td class="docs"><p><code>done</code> &mdash; Blocks until the server process terminates or the timeout
expires. Call this function after an orderly shutdown or a call to <code>scram</code>.</p>

<p>An orderly shutdown consists of calling the <code>shutdown</code> function, then
telling the plugin server process to shutdown through IPC. An orderly
shutdown should be performed when the plugin library is unloaded and the
library deinitialization function is called.</p>

<p>After initiating an orderly shutdown, wait on <code>done</code> with a resonable
timeout. If the timeout expires, <code>done</code> will return false.</p>

<p>If <code>done</code> returns false you should force plugin server termination with by
calling the <code>scram</code> function.</p></td>
          <td class="code"><div class="highlight"><pre>
</pre></div></td>
        </tr>
      
        <tr>
          <td class="docs"><p>&#9824; </p></td>
          <td class="code"><div class="highlight"><pre>
  <span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">done</span><span class="p">)(</span><span class="kt">int</span> <span class="n">milliseconds</span><span class="p">);</span>
</pre></div></td>
        </tr>
      
        <tr>
          <td class="docs"><p><code>scram</code> &mdash; We give you a way to obliterate the process here, this
triggers a hard shutdown of the process using harsh methods to pull the rug
out from under your server process. Your server process will not have a
chance to call any cleanup routines, it will just disappear. This is a last
resort.</p></td>
          <td class="code"><div class="highlight"><pre>
</pre></div></td>
        </tr>
      
        <tr>
          <td class="docs"><p>&#9824; </p></td>
          <td class="code"><div class="highlight"><pre>
  <span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">scram</span><span class="p">)();</span>
</pre></div></td>
        </tr>
      
        <tr>
          <td class="docs"><p><code>errors</code> &mdash; Returns an integer array of two elements relating to the
last error encountered by the plugin attendant. The first element is a
plugin attendant error code.</p>

<p>Errors can be checked after a failed call to one of the plugin attendant
function, or else at the start of a call to the plugin developer suppliesd
<code>abend</code> function, before any plugin attendant functions are called, to
obtain the reason why the abend function was called.</p>

<p>Errors generated by the problems with the plugin attendant itself are
really assertions. The plugin attendant has so few moving parts that if it
cannot function, there is something wrong with configuration or
instalation of the plugin.</p>

<p>Errors indicating that the plugin process cannot start would also indicate
that there is a problem with configuration or installation.</p>

<p>When the plugin server process crashes, the <code>errors</code> function will give a
a reason so vauge as to be useless. The plugin server process should
maintain a log that can be referenced to see where it terminated, or a
crash log that records the stack before exit. Using a crash reporter, and
with the end user's permission, you can use this log to diagnose errors.</p>

<p>There are a few errors that are marked as assertions. If you detect one of
these errors, then I've made an assumption about how the plugin attendant
is supposed to work that your experience in the field has proven false.</p>

<p>Please inform me of these assertions if they arise.</p></td>
          <td class="code"><div class="highlight"><pre>
</pre></div></td>
        </tr>
      
        <tr>
          <td class="docs"><p>&#9824; </p></td>
          <td class="code"><div class="highlight"><pre>
  <span class="k">struct</span> <span class="n">attendant__errors</span> <span class="p">(</span><span class="o">*</span><span class="n">errors</span><span class="p">)();</span>
</pre></div></td>
        </tr>
      
        <tr>
          <td class="docs"><p><code>destroy</code> &mdash; Called after the plugin process server has shutdown, the
plugin attendant has entered the shutdown state. Call this function after
shutdown to free a few resources before the library is unloaded.</p></td>
          <td class="code"><div class="highlight"><pre>
</pre></div></td>
        </tr>
      
        <tr>
          <td class="docs"><p>&#9824; </p></td>
          <td class="code"><div class="highlight"><pre>
  <span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">destroy</span><span class="p">)();</span>

<span class="cp">#ifdef _DEBUG</span></pre></div></td>
        </tr>
      
        <tr>
          <td class="docs"><p><code>tracepoints</code> &mdash; Returns a null terminated  of tracepoints as
formatted strings. Each tracepoint takes the form of <code>[function/event]</code>.
For example, <code>[initialize/success]</code> or <code>[reaper/shutdown]</code>.</p>

<p>The tracer is limited to 255 trace points. It stop gathering trace points
after the limit is reached.</p>

<p>The trace is used only with unit testing. This is not a general purpose
logging mechanism.</p></td>
          <td class="code"><div class="highlight"><pre><span class="cp"></span>
</pre></div></td>
        </tr>
      
        <tr>
          <td class="docs"><p>&#9824; </p></td>
          <td class="code"><div class="highlight"><pre>
  <span class="kt">char</span> <span class="o">**</span><span class="p">(</span><span class="o">*</span><span class="n">tracepoints</span><span class="p">)();</span></pre></div></td>
        </tr>
      
        <tr>
          <td class="docs"></td>
          <td class="code"><div class="highlight"><pre>
<span class="cp">#endif</span>
<span class="p">};</span>
</pre></div></td>
        </tr>
      
        <tr>
          <td class="docs"><p>The one and only plugin attendant. </p></td>
          <td class="code"><div class="highlight"><pre>
<span class="k">extern</span> <span class="k">struct</span> <span class="n">attendant</span> <span class="n">attendant</span><span class="p">;</span>
</pre></div></td>
        </tr>
      
        <tr>
          <td class="docs"><p>Love, C. </p></td>
          <td class="code"><div class="highlight"><pre>
<span class="cp">#ifdef __cplusplus</span>
<span class="p">}</span>
<span class="cp">#endif</span>

</pre></div></td>
        </tr>
      
    </tbody>
  </table>
</div>
</body>
</html>
