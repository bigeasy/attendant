<!DOCTYPE html>
<html>
<head>
<title></title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<link rel="stylesheet" media="all" href="/attendant/css/docco.css">
</head>
<body>
<div id="container">
<div id="background"></div>
<!DOCTYPE html>

<html>
<head>
  <title>./relay_posix.c</title>
  <meta http-equiv="content-type" content="text/html; charset=UTF-8">
  <link rel="stylesheet" media="all" href="/attendant/css/docco.css">
</head>
<body>
<div id="container">
<a href="http://github.com/bigeasy/strata"><img
  style="position: fixed; top: 0; right: 0; border: 0;"
  src="http://s3.amazonaws.com/github/ribbons/forkme_right_orange_ff7600.png" alt="Fork me on GitHub" /></a>
<div id="background"></div>
  <table cellspacing="0" cellpadding="0">
    <thead>
      <tr>
        <th class="docs"><h1></th>
        <th class="code"></th>
      </tr>
    </thead>
    <tbody>
      
        <tr>
          <td class="docs"><p>There is a lot of work to do to create clean slate for our server process,
and the easiest way to get there is to have an intremediate program occupy
the process.</p>

<p>Initially, I tried to do this was going to take place in the attendant
library start up function, linked to the host application, after fork and
before execve. That whole block of code felt like a race condition.</p>

<p>By stepping on this stepping stone, we do our setup in an exec'd program in a
far less fragile state that a fork within a multi-threaded program.</p></td>
          <td class="code"><div class="highlight"><pre><span class="cp">#include &lt;unistd.h&gt;</span>
<span class="cp">#include &lt;stdio.h&gt;</span>
<span class="cp">#include &lt;stdlib.h&gt;</span>
<span class="cp">#include &lt;dirent.h&gt;</span>
<span class="cp">#include &lt;fcntl.h&gt;</span>
<span class="cp">#include &lt;signal.h&gt;</span>
<span class="cp">#include &lt;limits.h&gt;</span>
<span class="cp">#include &lt;errno.h&gt;</span>
</pre></div></td>
        </tr>
      
        <tr>
          <td class="docs"><p>Contains error code that will be written to stderr and read by a startup
thread running in the host application launched by the attendant library. </p></td>
          <td class="code"><div class="highlight"><pre>
<span class="cp">#include &quot;errors.h&quot;</span>
<span class="cp">#include &quot;eintr.h&quot;</span>
</pre></div></td>
        </tr>
      
        <tr>
          <td class="docs"><p>The first argument to the program is file handle of a pipe used to report
errors to the library proecess start thread in the host application. We use
this extra pipe instead of STDERR or STDOUT because it will be closed on
exec. We set all non-stdio file descriptrs to close on exit so that the
server process will not inherit file descriptors from the host application.
The start thread blocks on the extra pipe reading a error code an errno
written using the send_error function. If it gets an EPIPE instead of an
error code, it knows that the relay program is done and the server program
has exec'd, so it knows that there were no errors in the relay program.</p></td>
          <td class="code"><div class="highlight"><pre>
<span class="k">static</span> <span class="kt">int</span> <span class="n">spipe</span><span class="p">,</span> <span class="n">pulse_pipe</span><span class="p">;</span>
</pre></div></td>
        </tr>
      
        <tr>
          <td class="docs"><p>True if a file handle is a stdio file handle. </p></td>
          <td class="code"><div class="highlight"><pre>
<span class="kt">int</span> <span class="nf">is_stdio</span><span class="p">(</span><span class="kt">int</span> <span class="n">fd</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="n">fd</span> <span class="o">==</span> <span class="n">STDIN_FILENO</span> <span class="o">||</span> <span class="n">fd</span> <span class="o">==</span> <span class="n">STDOUT_FILENO</span> <span class="o">||</span> <span class="n">fd</span> <span class="o">==</span> <span class="n">STDERR_FILENO</span><span class="p">;</span>
<span class="p">}</span>
</pre></div></td>
        </tr>
      
        <tr>
          <td class="docs"><p>When the host application is a multi-threaded application, many for the
standard library functions are unavailable between fork and execvp. We cannot
call malloc for example. That presents a problem for us in our file handler
cleanup code.</p>

<p>The only reliable way to get a list of file handles from Linux or OS X is to
do a directory listing of "/dev/fd". The <code>opendir</code> function calls malloc.
Thus, we cannot do a directory listing between fork and execve.</p>

<p>We could do a directory listing before we fork, but now we have a race
condition. After fork, the set of open file handles is fixed. We have a copy
of all the file handles in the parent, but after fork, if the parent opens a
file, the forked child will not see it. The child will only see the file
handles that it opens itself.</p>

<p>Before we fork, we can create a list of open file descriptors in an array,
but from the moment we're done reading the directory listing of "/dev/fd", to
the moment we fork, another thread may open a new file.</p>

<p>I got the point that I was thinking that the library server process would
want to double check that an inherited open file handle was skipped. From
there I realized that I might as well load an intermediate program that does
this cleanup. Do it once and do it right. </p>

<p>Furthermore, the well-behaved host application is going to set FD_CLOEXEC
flag on the file it creates. This would close those file descriptors in the
child process when execve is called in the startup thread. The set of
inherited file descriptors after fork is every open file descriptor in the
host application. Doing the file descriptor cleanup here, after execve, will
probably mean fewer file descriptors to close.</p>

<p>Rather than closing the file descriptors, we set the close on exec flag
FD_CLOEXEC. This is because the attendent library in the host application has
fed us a senty file descriptor that is the write end of a pipe. When we set
FD_CLOEXEC on that file descriptor and then execve, a read from the read end
of the pipe will generate and EPIPE. This program will send a success code
through STDERR prior to execve. If the startup thread recieves the success
code, it reads from the senty pipe until it gets an EPIPE. At that point it
knows that the server program has been loaded into the process.</p></td>
          <td class="code"><div class="highlight"><pre>
<span class="kt">void</span> <span class="nf">set_close_on_exec</span><span class="p">()</span> <span class="p">{</span>
  <span class="kt">DIR</span> <span class="o">*</span><span class="n">dir</span><span class="p">;</span>
  <span class="k">struct</span> <span class="n">dirent</span> <span class="o">*</span><span class="n">ent</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">fd</span><span class="p">;</span>

  <span class="n">dir</span> <span class="o">=</span> <span class="n">opendir</span><span class="p">(</span><span class="s">&quot;/dev/fd&quot;</span><span class="p">);</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">dir</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">send_error</span><span class="p">(</span><span class="n">spipe</span><span class="p">,</span> <span class="n">RELAY_CANNOT_OPEN_DEV_FD</span><span class="p">);</span>
  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
    <span class="k">while</span> <span class="p">((</span><span class="n">ent</span> <span class="o">=</span> <span class="n">readdir</span><span class="p">(</span><span class="n">dir</span><span class="p">))</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">fd</span> <span class="o">=</span> <span class="n">atoi</span><span class="p">(</span><span class="n">ent</span><span class="o">-&gt;</span><span class="n">d_name</span><span class="p">);</span>
      <span class="k">if</span> <span class="p">(</span><span class="o">!</span> <span class="n">is_stdio</span><span class="p">(</span><span class="n">fd</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">fd</span> <span class="o">!=</span> <span class="n">dirfd</span><span class="p">(</span><span class="n">dir</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">fd</span> <span class="o">!=</span> <span class="n">pulse_pipe</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">fcntl</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span> <span class="n">F_SETFD</span><span class="p">,</span> <span class="n">FD_CLOEXEC</span><span class="p">);</span>
      <span class="p">}</span>
    <span class="p">}</span>
    <span class="n">closedir</span><span class="p">(</span><span class="n">dir</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></div></td>
        </tr>
      
        <tr>
          <td class="docs"><p>Signals need to be returned to their default disposition. When forked, the
child process will inherit signal handlers and their settings. After an
execve, however, signals are reset to their default disposition, except for
those signals that the host application chose to ignore. Ignored signals in
the parent process are also ignored in the exceve process.</p>

<p>We check to see if any signal handlers are set to SIG_IGN. If so, we return
them to the default SIG_DFL. The server program will then have a blank slate
of signal handlers.</p></td>
          <td class="code"><div class="highlight"><pre>
</pre></div></td>
        </tr>
      
        <tr>
          <td class="docs"><p>We don't gaurd against a host application that considers us an attacker. The
library process attendent is linked into a dynamically loaded library
implemented to extend the an application that provides a plugin mechanism.
The host application will have loaded the plugin. The host application should
expect the plugin to open files, sockets, etc.</p>

<p>This is because the attendent library is dynamically loaded into
a host application, where the library has no control over the global
environment. It cannot make assumptions about the disposition of signal han</p>

<p>This process is going to close down any file handles left open
from out library launcher. It doesn't have any restrictions on signal
handlers, memory allocation, file handles, threads. It can use what ever
resources it wants, close things up, and then execve.</p></td>
          <td class="code"><div class="highlight"><pre>
<span class="kt">int</span> <span class="nf">reset_signals</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">struct</span> <span class="n">sigaction</span> <span class="n">sig</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">signum</span><span class="p">;</span>
  <span class="k">for</span> <span class="p">(</span><span class="n">signum</span> <span class="o">=</span> <span class="n">SIGHUP</span><span class="p">;</span> <span class="n">signum</span> <span class="o">&lt;</span> <span class="n">NSIG</span><span class="p">;</span> <span class="n">signum</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">sigaction</span><span class="p">(</span><span class="n">signum</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sig</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">sig</span><span class="p">.</span><span class="n">sa_handler</span> <span class="o">==</span> <span class="n">SIG_IGN</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">sig</span><span class="p">.</span><span class="n">sa_handler</span> <span class="o">=</span> <span class="n">SIG_DFL</span><span class="p">;</span>
      <span class="n">sigaction</span><span class="p">(</span><span class="n">signum</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sig</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></div></td>
        </tr>
      
        <tr>
          <td class="docs"><p>The first argument is our status pipe, so me make sure it is alive.
If we didn't even get a first argument, we just exit.  If we did, we convert
it and write to stdout.  The start thread will listen for this and assert
that we're going to use the correct pipe for status reporting.  If it doesn't
get the correct fd on stdout, it knows that we weren't able to get past this
step. If we send the wrong fd, then the start thread can record the error and
give up on launching the server process altogether, because that would be a
really fundimental error. </p></td>
          <td class="code"><div class="highlight"><pre>
<span class="kt">void</span> <span class="nf">get_status_pipe</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">argv</span><span class="p">[])</span> <span class="p">{</span>
  <span class="kt">int</span> <span class="n">err</span><span class="p">;</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">argc</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">)</span> <span class="n">exit</span><span class="p">(</span><span class="mi">127</span><span class="p">);</span>
  <span class="n">spipe</span> <span class="o">=</span> <span class="n">atoi</span><span class="p">(</span><span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">spipe</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span></pre></div></td>
        </tr>
      
        <tr>
          <td class="docs"><p>Can't be right. </p></td>
          <td class="code"><div class="highlight"><pre>
    <span class="n">exit</span><span class="p">(</span><span class="mi">127</span><span class="p">);</span>
  <span class="p">}</span>
  <span class="n">HANDLE_EINTR</span><span class="p">(</span><span class="n">write</span><span class="p">(</span><span class="n">STDOUT_FILENO</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">spipe</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">spipe</span><span class="p">)),</span> <span class="n">err</span><span class="p">);</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">exit</span><span class="p">(</span><span class="mi">127</span><span class="p">);</span>
  <span class="p">}</span></pre></div></td>
        </tr>
      
        <tr>
          <td class="docs"><p>Now we prove to the start thread that the pipe is working by sending the
pipe fd back trough the pipe itself. </p></td>
          <td class="code"><div class="highlight"><pre>
  <span class="n">HANDLE_EINTR</span><span class="p">(</span><span class="n">write</span><span class="p">(</span><span class="n">spipe</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">spipe</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">spipe</span><span class="p">)),</span> <span class="n">err</span><span class="p">);</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">exit</span><span class="p">(</span><span class="mi">127</span><span class="p">);</span>
  <span class="p">}</span></pre></div></td>
        </tr>
      
        <tr>
          <td class="docs"><p>Now we know that error reporting will work correctly, so check that we have
a program to run specified by an absolute path before we go one. </p></td>
          <td class="code"><div class="highlight"><pre>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">get_pulse_pipe</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">argv</span><span class="p">[])</span> <span class="p">{</span>
  <span class="kt">char</span> <span class="o">*</span><span class="n">end</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">err</span><span class="p">;</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">argc</span> <span class="o">&lt;</span> <span class="mi">3</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">send_error</span><span class="p">(</span><span class="n">spipe</span><span class="p">,</span> <span class="n">RELAY_PULSE_PIPE_MISSING</span><span class="p">);</span>
  <span class="p">}</span>
  <span class="n">pulse_pipe</span> <span class="o">=</span> <span class="n">atoi</span><span class="p">(</span><span class="n">argv</span><span class="p">[</span><span class="mi">2</span><span class="p">]);</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">pulse_pipe</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">send_error</span><span class="p">(</span><span class="n">spipe</span><span class="p">,</span> <span class="n">RELAY_PULSE_PIPE_MALFORMED</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></div></td>
        </tr>
      
        <tr>
          <td class="docs"><p>We check to see that we received a program name and that the path is
absolute. We'll let execl determine if the program does actually exist as an
executable on the filesystem.</p></td>
          <td class="code"><div class="highlight"><pre>
<span class="kt">void</span> <span class="nf">verify_arguments</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">argv</span><span class="p">[])</span> <span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">argc</span> <span class="o">&lt;</span> <span class="mi">4</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">send_error</span><span class="p">(</span><span class="n">spipe</span><span class="p">,</span> <span class="n">RELAY_PROGRAM_MISSING</span><span class="p">);</span>
  <span class="p">}</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">argv</span><span class="p">[</span><span class="mi">3</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="sc">&#39;/&#39;</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">send_error</span><span class="p">(</span><span class="n">spipe</span><span class="p">,</span> <span class="n">RELAY_PROGRAM_PATH_NOT_ABSOLUTE</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">execute</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">argv</span><span class="p">[])</span> <span class="p">{</span>
  <span class="kt">char</span> <span class="o">*</span><span class="n">args</span><span class="p">[</span><span class="n">ARG_MAX</span><span class="p">];</span>
  <span class="kt">char</span> <span class="o">*</span><span class="n">path</span> <span class="o">=</span> <span class="n">argv</span><span class="p">[</span><span class="mi">3</span><span class="p">];</span>
  <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

  <span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">path</span><span class="p">;</span>
  <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">argc</span> <span class="o">-</span> <span class="mi">4</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">args</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">argv</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">4</span><span class="p">];</span>
  <span class="p">}</span>
  <span class="n">args</span><span class="p">[</span><span class="n">argc</span> <span class="o">-</span> <span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
</pre></div></td>
        </tr>
      
        <tr>
          <td class="docs"><p>fprintf(stderr, "path %s\n", path);
  for (i = 0; args[i]; i++) {
    fprintf(stderr, "arg %s\n", args[i]);
  }</p></td>
          <td class="code"><div class="highlight"><pre>
</pre></div></td>
        </tr>
      
        <tr>
          <td class="docs"><p>Obliterate ourselves. </p></td>
          <td class="code"><div class="highlight"><pre>
  <span class="n">execv</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="n">args</span><span class="p">);</span>
</pre></div></td>
        </tr>
      
        <tr>
          <td class="docs"><p>If we are here then execl failed. </p></td>
          <td class="code"><div class="highlight"><pre>
  <span class="n">send_error</span><span class="p">(</span><span class="n">spipe</span><span class="p">,</span> <span class="n">RELAY_CANNOT_EXEC</span><span class="p">);</span>
<span class="p">}</span>
</pre></div></td>
        </tr>
      
        <tr>
          <td class="docs"><p>Perform the cleaning operations and execve the server process. </p></td>
          <td class="code"><div class="highlight"><pre>
<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">argv</span><span class="p">[])</span> <span class="p">{</span></pre></div></td>
        </tr>
      
        <tr>
          <td class="docs"><p>Get the first argument, the status pipe, where we report any errors. </p></td>
          <td class="code"><div class="highlight"><pre>
  <span class="n">get_status_pipe</span><span class="p">(</span><span class="n">argc</span><span class="p">,</span> <span class="n">argv</span><span class="p">);</span>
</pre></div></td>
        </tr>
      
        <tr>
          <td class="docs"><p>Get the second, the pulse pipe that we're not supposed to close. </p></td>
          <td class="code"><div class="highlight"><pre>
  <span class="n">get_pulse_pipe</span><span class="p">(</span><span class="n">argc</span><span class="p">,</span> <span class="n">argv</span><span class="p">);</span>
</pre></div></td>
        </tr>
      
        <tr>
          <td class="docs"><p>Check that the third argument is a relay program. The remainder of the
arguments are arguments for the relay program. </p></td>
          <td class="code"><div class="highlight"><pre>
  <span class="n">verify_arguments</span><span class="p">(</span><span class="n">argc</span><span class="p">,</span> <span class="n">argv</span><span class="p">);</span>
</pre></div></td>
        </tr>
      
        <tr>
          <td class="docs"><p>Reset signals. </p></td>
          <td class="code"><div class="highlight"><pre>
  <span class="n">reset_signals</span><span class="p">();</span>
</pre></div></td>
        </tr>
      
        <tr>
          <td class="docs"><p>Set all non-stdio file handles to close on exec. </p></td>
          <td class="code"><div class="highlight"><pre>
  <span class="n">set_close_on_exec</span><span class="p">();</span>
</pre></div></td>
        </tr>
      
        <tr>
          <td class="docs"><p>Call execve to replace this relay program with the server program. </p></td>
          <td class="code"><div class="highlight"><pre>
  <span class="n">execute</span><span class="p">(</span><span class="n">argc</span><span class="p">,</span> <span class="n">argv</span><span class="p">);</span>
</pre></div></td>
        </tr>
      
        <tr>
          <td class="docs"><p>This program ought to have been replaced by the library server program 
by now. If not, it would have sent an error and exited. If we are here, we
have failed and failed at failing. The shame. It burns. </p></td>
          <td class="code"><div class="highlight"><pre>
  <span class="k">return</span> <span class="n">EXIT_FAILURE</span><span class="p">;</span>
<span class="p">}</span>

</pre></div></td>
        </tr>
      
    </tbody>
  </table>
</div>
</body>
</html>
